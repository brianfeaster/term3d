#!/bin/bash

## Poor man's console 3d lib

## _Concepts_
## _Useful_
## _Testing_
## _Math_
## _Time_
## _Terminal_
## _Debuggin_
## _Vectors_
## _Planes_
## _Objects_
## _Matrices_
## _Globals_
## _Rendering_
## _Build_

#### _Concepts_
##
##  * Vectors and matrices are arrays and passed by value as individual args, a
##    quoted expanded list, or referenced directly by the callee due to
##    function's dynamic scoping.
##  * Everything's fixed point because bash math has no floating math support.
##  * Unit circle radius=120
##  * Radian SINTABLE 120 in size
##  * Presume +Z extends beyond screen away from viewer.
##
## Arrays vs function arguments:
##
##  Although you can pass an array as a symbolic reference to a function as 'ary[@]'
##  then copy it locally with myary=(${!1}), it's faster just to pass the array around
##  as an expanded list of values "${ary[*]}" and copied locally with myary=($1) or
##  just used directly and consumed along with shift which seems to be the fastest.
##  Relying on dynamic scoping is event faster.
##
##  Implementing matrix multiply with a dynamic scopped target matrix isn't any
##  faster than passing all the elements as args and returning the matrix symbolically.
##
## Depth-buffer
##
##  Up until now the z coordinate has been ignored as a form of 2d projection.  Now it
##  needs to be considered when determining depth for inclusion into the the z-buffer
##  array.  The line drawing algorithm will just compute the z coordinate given either
##  the x (slope between -1 and 1) or y (slope beyond -1 or 1).  There may be a DDA
##  method that will be faster but for now this should suffice.
##
## Frame-Buffer
##
##  The terminal can't be written to directly now.  Instead 3d coordinates and
##  character the character/color will will be generated for all visible 'points'
##  then all used to populate the depth buffer.
##
## Model Store
##
##  Replace below with something that registers points (which may move) and faces that can be drawn from said points
##  The first three points of the face defines two vectors for normal computation
##    points: a b c d  e f g h ...
##    faces:  0 1 2 3  4 5 6 7  1 0 4 5  1 2 5 6 ...
##    norm:   0 1 3    4 5 7    1 0 5
##
##  Each vertex and model will be stored in global lists.  Another mechanism will be
##  used to apply copying transformations to the vertices in the global list.  The
##  renderer shouldn't care.
##
## Normal Lists
##
##  Objects that share a facing normal will share a common normal to be transformed
##  and calculated en masse prior to scheduling the rest of the rendering.
##
## Object transform List
##
##  Transformation matrix applied to one or more facing and object groups.  The global
##  matrix needs to be applied first before using so there needs to be a pre and
##  post transformed list.
##
## Signal races
##
##  Usualy after a SIGINT from keyboard a subprocess doesn't finish writing the final
##  sentinel to signal the next thread to display its frame.  I believe the signal
##  is coming in before the new process is able to register a SIGINT ignore handler.
##
## Issues
##
##  It would appear when sleeping or even 'read -t'ing, signal handlers and/or child
##  processes that also sleep will be silently killed.  Or maybe it's the trap
##  handler that's killed.  It was a mess.  I've cleaned up the event and signal
##  loop.
##
####



##
## _Useful_
##
function waitThenDelete { # (filename [origin] delay)
  local fn=$1

  # Spin waiting for file to appear
  while [ ! -e $fn ]; do >&2 echo "Waiting for '$fn'  ${2:+\"$2\"}  Sleep ${3:-.06}"...; sleep ${3:-.06}; done

  # Delete until successful
  while ! rm $fn; do
    >&2 echo "Trying to delete '$fn'  ${2:+\"$2\"}"
  done
}



#### _Testing_
##
function assertEquals {
  IFS=''
  local title="$1" res="$2" exp="$3"
  #echo -e "\e[32m$1\n\e[0;31m$2\e[0m"
  if [ "$res" != "$exp" ]; then
    echo -e "\e[31;1m[FAIL] $title\e[0;33m"
    diff <(echo $res) <(echo $exp)
    echo -e "\e[0m"
    exit $?
  fi
  unset IFS
}
#### _Testing_



##
## _Math_  Mappings from [0..120] -> [-120..120]
##
SINTABLE=(0 6 12 18 25 31 37 43 49 54 60 65 70 75 80 85 89 93 97 101 104 107 110 112 114 116 117 119 119 120 120 120 119 119 117 116 114 112 110 107 104 101 97 93 89 85 80 75 70 65 60 54 49 43 37 31 25 18 12 6 0 -6 -12 -18 -25 -31 -37 -43 -49 -54 -60 -65 -70 -75 -80 -85 -89 -93 -97 -101 -104 -107 -110 -112 -114 -116 -117 -119 -119 -120 -120 -120 -119 -119 -117 -116 -114 -112 -110 -107 -104 -101 -97 -93 -89 -85 -80 -75 -70 -65 -60 -54 -49 -43 -37 -31 -25 -18 -12 -6)
SINTABLEI=(0 -6 -12 -18 -25 -31 -37 -43 -49 -54 -60 -65 -70 -75 -80 -85 -89 -93 -97 -101 -104 -107 -110 -112 -114 -116 -117 -119 -119 -120 -120 -120 -119 -119 -117 -116 -114 -112 -110 -107 -104 -101 -97 -93 -89 -85 -80 -75 -70 -65 -60 -54 -49 -43 -37 -31 -25 -18 -12 -6 0 6 12 18 25 31 37 43 49 54 60 65 70 75 80 85 89 93 97 101 104 107 110 112 114 116 117 119 119 120 120 120 119 119 117 116 114 112 110 107 104 101 97 93 89 85 80 75 70 65 60 54 49 43 37 31 25 18 12 6)
COSTABLE=(120 120 119 119 117 116 114 112 110 107 104 101 97 93 89 85 80 75 70 65 60 54 49 43 37 31 25 18 12 6 0 -6 -12 -18 -25 -31 -37 -43 -49 -54 -60 -65 -70 -75 -80 -85 -89 -93 -97 -101 -104 -107 -110 -112 -114 -116 -117 -119 -119 -120 -120 -120 -119 -119 -117 -116 -114 -112 -110 -107 -104 -101 -97 -93 -89 -85 -80 -75 -70 -65 -60 -54 -49 -43 -37 -31 -25 -18 -12 -6 0 6 12 18 25 31 37 43 49 54 60 65 70 75 80 85 89 93 97 101 104 107 110 112 114 116 117 119 119 120)
COSTABLEI=(-120 -120 -119 -119 -117 -116 -114 -112 -110 -107 -104 -101 -97 -93 -89 -85 -80 -75 -70 -65 -60 -54 -49 -43 -37 -31 -25 -18 -12 -6 0 6 12 18 25 31 37 43 49 54 60 65 70 75 80 85 89 93 97 101 104 107 110 112 114 116 117 119 119 120 120 120 119 119 117 116 114 112 110 107 104 101 97 93 89 85 80 75 70 65 60 54 49 43 37 31 25 18 12 6 0 -6 -12 -18 -25 -31 -37 -43 -49 -54 -60 -65 -70 -75 -80 -85 -89 -93 -97 -101 -104 -107 -110 -112 -114 -116 -117 -119 -119 -120)

function range { eval echo {$1..$2}; }
function prerange { eval echo $1{$2..$3}; }


##
## _Time_
##
## Consider time as normalized values:  hours [0..240] minuts & seconds [0..120].
## I do this because the above trig function domains are [0..120].
##
hour=0
min=0
sec=0
function timeProbe {
  local h m s
  if (($#==1)); then
    read h m s <<< $(date -r $1 +'%H %M %S')
  else
    read h m s  <<< $(date +'%H %M %S')
  fi
  ((hour=10#$h * 10)) #10# forces base 10 values otherwise octal 09 can't be parsed.
  ((min=10#$m * 2))
  ((sec=10#$s * 2))
}
timeProbe $(date +'%H %M %S')



##
## _Terminal_
##
TWIDTH=80
TWIDTH2=40
THEIGHT=25
THEIGHT2=13
function hex { printf "%02x" $1; }
# UTF-8 critter glyphs
function acritter { printf "\xf0\x9f\x90\x${1:-$(hex $((128+RANDOM%64)))}"; }
function resetCritters {
  animal1=$(acritter)
  animal2=$(acritter)
  animal3=$(acritter)
}
resetCritters

function terminalProbe {
  read THEIGHT TWIDTH <<<$(stty size)
  ((THEIGHT2=THEIGHT/2))
  ((TWIDTH2=TWIDTH/2))
}

function terminalIsInScreen { # ARGS: x y
  local x=$(($1+TWIDTH2))
  local y=$(($2+THEIGHT2))
  ! ((x<0 || y<0 || TWIDTH<=x || THEIGHT<=y))
}

function G2 { printf "\e[$(($1+THEIGHT2));$(($2+TWIDTH2))H$3"; }

function terminalDrawLine { # ( z y x  z' y' x'  cl  ch)
  local x y z  m n o  dx dy dz  w ws nx ny yyxx e i
  local z=$5
  local kl=$7
  local ch=$8
  # Make sure line is drawn from left -x to right +x in the temrinal.
  if (($3<=$6)); then
    x=$3; y=$2; z=$1; m=$6; n=$5; o=$4
  else
    x=$6; y=$5; z=$4; m=$3; n=$2; o=$1
  fi
  # (x,y) to (m,n) will always go left to right
  ((dx=m-x))
  if (($2<$5)); then ((dy=$5-$2)); else ((dy=$2-$5)); fi
  ((dz=o-z))

  # Always walk or walk-step

  if ((dy<dx)); then # Small slope so walk left and step up or down
    w=''; xwi=1;  ywi=0
    if ((y<n)); then # walk right and down
       ws=$'\v'; xwsi=1; ywsi=1
    else                   # walk right and up
       ws=$'\eM'; xwsi=1; ywsi=-1
    fi
    nx=$dx
    ny=$dy
  else # Large slope, so walk up or down and step right
    if ((y<n)); then # walk down and right
       w=$'\b\v'; xwi=0; ywi=1
       ws=$'\v'; xwsi=1; ywsi=1
    else                   # walk up and right
       w=$'\b\eM'; xwi=0; ywi=-1
       ws=$'\eM'; xwsi=1; ywsi=-1
    fi
    nx=$dy
    ny=$dx
  fi

  # Valid state when drawing lines on the terminal
  #  0 = out
  #  1 = in
  local state=0

  ((yy=ny+ny,yyxx=yy-nx-nx,e=yy-nx,i=nx,dz=z-o))

  while ((0<i)); do
    if ((0<=e)); then # above mid-point
      if ((state==1)); then
        if terminalIsInScreen $x $y; then # done if out of screen
          echo $((x+TWIDTH2)) $((y+THEIGHT2)) $((z-dz*(nx-i)/nx)) $kl $ch
        else
           return 0
        fi
      else # state == 0
        if terminalIsInScreen $x $y; then
          state=1
          echo $((x+TWIDTH2)) $((y+THEIGHT2)) $((z-dz*(nx-i)/nx)) $kl $ch
        fi
      fi
      ((x+=xwsi,y+=ywsi,e+=yyxx))
    else # below mid-point
      if ((1==state)); then
        if terminalIsInScreen $x $y; then  # done if out of screen
          echo $((x+TWIDTH2)) $((y+THEIGHT2)) $((z-dz*(nx-i)/nx)) $kl $ch
        else
          return 0
        fi
      else # state == 0
        if terminalIsInScreen $x $y; then
          state=1
          echo $((x+TWIDTH2)) $((y+THEIGHT2)) $((z-dz*(nx-i)/nx)) $kl $ch
        fi
      fi
      ((x+=xwi,y+=ywi,e+=yy))
    fi
    ((--i))
  done
}


function terminalDrawLineDirect {
  local x y m n dx dy w ws nx ny yyxx e i
  # Make sure line is drawn from left -x to right +x in the temrinal.
  if [ $2 -le $4 ]; then
    x=$2; y=$1; m=$4; n=$3
  else
    x=$4; y=$3; m=$2; n=$1
  fi
  # (x,y) to (m,n) will always go left to right
  dx=$((m-x))
  if [ $1 -lt $3 ]; then dy=$(($3-$1)); else dy=$(($1-$3)); fi

  # Always walk or walk-step

  if [ $dy -lt $dx ]; then # Small slope so walk left and step up or down
    w=''; xwi=1;  ywi=0
    if [ $y -lt $n ]; then # walk right and down
       ws=$'\v'; xwsi=1; ywsi=1
    else                   # walk right and up
       ws=$'\eM'; xwsi=1; ywsi=-1
    fi
    nx=$dx
    ny=$dy
  else # Large slope, so walk up or down and step right
    if [ $y -lt $n ]; then # walk down and right
       w=$'\b\v'; xwi=0; ywi=1
       ws=$'\v'; xwsi=1; ywsi=1
    else                   # walk up and right
       w=$'\b\eM'; xwi=0; ywi=-1
       ws=$'\eM'; xwsi=1; ywsi=-1
    fi
    nx=$dy
    ny=$dx
  fi

  # Valid state when drawing lines on the terminal
  #  0 = out
  #  1 = in
  local state=0

  yy=$((ny + ny))
  yyxx=$((yy - nx - nx))
  e=$((yy - nx))
  i=$nx

  while [ 0 -lt $i ]; do
    if [ 0 -le $e ]; then
      if [ $state == 1 ]; then
        if ! terminalIsInScreen $x $y; then # done if out of screen
           return 0
        fi
        printf "$ws$5"
      else # state == 0
        if terminalIsInScreen $x $y; then
          G2 $y $x $5
          state=1
        fi
      fi
      x=$((x+xwsi)); y=$((y+ywsi))
      e=$((e + yyxx))
    else
      if [ $state == 1 ]; then
        if !terminalIsInScreen $x $y; then # done if out of screen
          return 0
        fi
        printf $w$5
      else # state == 0
        if terminalIsInScreen $x $y
          then G2 $y $x $5
          state=1
        fi
      fi
      x=$((x+xwi)); y=$((y+ywi))
      e=$((e + yy))
    fi
    i=$((i-1))
  done
}



##
## Debugging
##
dv   (){ while [ 0 -lt $# ]; do printf '[%3d %3d %3d %3d ]\n' $1 $2 $3 $4; shift; shift; shift; shift ; done; }
dvgl (){ while [ 0 -lt $# ]; do printf "($2 $3 $4 $5 $6)\n"; shift 6; done; }
dvn  (){ while [ 0 -lt $# ]; do printf '[%6d %6d %6d %6d | %6d]\n' $(($1/$4)) $(($2/$4)) $(($3/$4)) $(($4/$4)) $4; shift 4; done; }
dm4  (){ while [ 0 -lt $# ]; do printf '[%9d %9d %9d %9d]\n' $1 $2 $3 $4 $5 $6 $7 $8 $9 ${10} ${11} ${12} ${13} ${14} ${15} ${16}; echo; shift 16; done; }
COLORS=('0' '0;31' '0;32' '0;33' '0;34' '0;35' '0;36' '0;37' '1;30' '1;31' '1;32' '1;33' '1;34' '1;35' '1;36' '1;37')
function PC { local c=$1; shift; printf "\e[${COLORS[c]}m$*"; }



##
## Vectors:  array of concatenated homogeneous 4d vectors.  (size count length)
##
vectors=()
function vectorsLength { echo $((${#vectors[*]}/4)); }
#function vectorsSetXYZN  {
#  local i=$1
#  x=${vectors[$i*4]}
#  y=${vectors[$i*4+1]}
#  z=${vectors[$i*4+2]}
#  n=${vectors[$i*4+3]}
#}
function vectorsAppend { # [x y z n ...] => &ret
  local len=${#vectors[*]}
  ret=$((len/4)) # keep track of the starting vector index
  while ((0<$#)); do
    vectors[len+0]=$1
    vectors[len+1]=$2
    vectors[len+2]=$3
    vectors[len+3]=$4
    shift 4
    ((len+=4))
  done
}

function vectorsDump {
  local i=0
  echo "-- $(vectorsLength) vectors ----"
  dv ${vectors[*]} | while read x; do echo $i $x; i=$((i+1)); done
}



#### _Planes_
##
## Array of indices into the vectors array pointing at groups of 4 consecutive vertices.  For normal occlusion.
##
planes=(-1 -1 -1 -1)    # Array of vector indices and matrix indices that reference three consecutive points in the vectors array defining a plane
facing=(1 0) # Result of normal calc for each plane (group of 3 normalized vertices) with two defaults (false true)
function planesLength { echo $((${#planes[*]}/2)); }
function planesAppend { # [ vectorsIdx matrixIdx ... ] => &ret
  local len=${#planes[*]}
  ((ret=len/2))
  while ((0<$#)); do
    planes[len]=$1
    planes[len+1]=$2

    facing[len/2]=-1
    shift ; shift
    ((len+=2))
  done
}

function planesDump {
  local i=2 v m max=$(planesLength)
  echo "-- $(planesLength) planes ----"

  echo 0: vecIdx=na matIdx=na [na] [na] [na] facing="${facing[0]}"
  echo 1: vecIdx=na matIdx=na [na] [na] [na] facing="${facing[1]}"

  while ((i<max)); do
    v=${planes[i*2]}
    m=${planes[i*2+1]}
    echo $i: vecIdx=$v matIdx=$m $(dv ${vectors[*]:v*4:12}) facing="${facing[i]}"
    ((++i))
  done
}

assertEquals Planes \
"$(vectorsAppend 0 0 0 0  1 1 1 1  2 2 2 2
   vectorsAppend 8 0 0 0  8 1 1 1  8 2 2 2
   vectorsAppend 9 0 0 0  9 1 1 1  9 2 2 2
   planesAppend 0 0  3 0  6 1
   planesDump)" \
"$(echo '-- 5 planes ----'
   echo '0: vecIdx=na matIdx=na [na] [na] [na] facing=1'
   echo '1: vecIdx=na matIdx=na [na] [na] [na] facing=0'
   echo '2: vecIdx=0 matIdx=0 [ 0 0 0 0 ] [ 1 1 1 1 ] [ 2 2 2 2 ] facing=-1'
   echo '3: vecIdx=3 matIdx=0 [ 8 0 0 0 ] [ 8 1 1 1 ] [ 8 2 2 2 ] facing=-1'
   echo '4: vecIdx=6 matIdx=1 [ 9 0 0 0 ] [ 9 1 1 1 ] [ 9 2 2 2 ] facing=-1')"

##
#### _Planes_


##
## _Objects_  Array of objects representing points, lines, and closed polygon
##
objects=() #( label type color char preMatIdx planeIdx vecIdxCount vecIdx... ...)

function objectsLength { : || complicated;  }

function objectsAdd { # Args: label type color char matIdx planeIdx vectorsIdx...
  local len=${#objects[*]}
  objects[len+0]=$1 # label
  objects[len+1]=$2 # type
  objects[len+2]=$3 # color
  objects[len+3]=$4 # char
  objects[len+4]=$5 # matIdx
  objects[len+5]=$6 # planeIdx
  shift 6
  objects[len+6]=$# # vector count
  ((len+=7))
  while ((0<$#)); do
    objects[len]=$1
    shift
    ((++len))
  done
}

function objectsDump {
  echo "-- objects ----"
  local oi=0 max=${#objects[*]} count p c=0
  while ((oi<max)); do
    printf "%d %8s %s [%d%s] m=%d " $c "\"${objects[oi+0]}\"" ${objects[oi+1]} ${objects[oi+2]} ${objects[oi+3]} ${objects[oi+4]}
    p=${objects[oi+5]}
    case $p in
      (0) printf "{F}" ;;
      (1) printf "{T}" ;;
      (*) printf "{%d}" $((p-2)) ;;
    esac
    count=${objects[oi+6]}
    printf " $count:"
    ((oi+=7))
    case ${objects[oi-6]} in
      (*) printf " %s" ${objects[*]:oi:count} ;;      # Dump indices representing each point
      (l) printf " %2d-%-2d" ${objects[*]:oi:count} ;; # Dump index pairs representing a line
    esac
    ((oi+=count))
    ((++c))
  done
}



##
## _Matrices_
##

matIdent="1 0 0 0  0 1 0 0   0 0 1 0  0 0 0 1"
function matRotz () { echo ${COSTABLE[(120+$1)%120]} ${SINTABLEI[(120+$1)%120]} 0 0 ${SINTABLE[(120+$1)%120]} ${COSTABLE[(120+$1)%120]} 0 0 0 0 120 0 0 0 0 120; }
function matRoty () { echo ${COSTABLE[($1+1201)%120]} 0 ${SINTABLEI[($1+1201)%120]} 0 0 120 0 0 ${SINTABLE[($1+120)%120]} 0 ${COSTABLE[($1+120)%120]} 0 0 0 0 120; }
function matRotx () { echo 120 0 0 0 0 ${COSTABLE[(120+$1)%120]} ${SINTABLE[(120+$1)%120]} 0 0   ${SINTABLEI[(120+$1)%120]} ${COSTABLE[(120+$1)%120]} 0 0 0 0 120; }
function matScale () { echo $1 0 0 0  0 $2 0 0  0 0 $3 0  0 0 0 1; }
function matTrans () { echo 1 0 0 $1  0 1 0 $2  0 0 1 $3  0 0 0 1; }
function matPerspective () { echo 1000 0 0 0  0 1000 0 0  0 0 1000 0  0 0 $((1000/$1)) 1000; }

#
# Multiply 4x4 row vector arg1 with 4xN column vector (remaining args).
#  Args: a b c d e f g h i j k l m n o p   x y z n ...
#
function matMultTransNVec () {
  local a=$1 b=$2 c=$3 d=$4 e=$5 f=$6 g=$7 h=$8 i=$9 j=${10} k=${11} l=${12} m=${13} n=${14} o=${15} p=${16}
  shift 12
  while ((8<=$#)) && shift 4; do
    echo $((a*$1+b*$2+c*$3+d*$4)) $((e*$1+f*$2+g*$3+h*$4)) $((i*$1+j*$2+k*$3+l*$4)) $((m*$1+n*$2+o*$3+p*$4))
  done
}


#
# Multiply N 4x4 row vectors passed expanded
#  Args: a b c d e f g h i j k l m n o p ...
#
function matMultNTrans () {
 (( 0 != $# % 16 && $# < 32 )) && { >&2 echo "matMultNTrans has not mod 16 args: [$*]"; echo $matIdent; }
 local a=$1 b=$2 c=$3 d=$4 e=$5 f=$6 g=$7 h=$8 i=$9 j=${10} k=${11} l=${12} m=${13} n=${14} o=${15} p=${16}
 local aa bb cc dd ee ff gg hh ii jj kk ll mm nn oo pp
 shift 16
 while :; do
   aa=$((a*$1 + b*$5 + c*$9    + d*${13}))
    bb=$((a*$2 + b*$6 + c*${10} + d*${14}))
     cc=$((a*$3 + b*$7 + c*${11} + d*${15}))
      dd=$((a*$4 + b*$8 + c*${12} + d*${16}))
   ee=$((e*$1 + f*$5 + g*$9    + h*${13}))
    ff=$((e*$2 + f*$6 + g*${10} + h*${14}))
     gg=$((e*$3 + f*$7 + g*${11} + h*${15}))
      hh=$((e*$4 + f*$8 + g*${12} + h*${16}))
   ii=$((i*$1 + j*$5 + k*$9    + l*${13}))
    jj=$((i*$2 + j*$6 + k*${10} + l*${14}))
     kk=$((i*$3 + j*$7 + k*${11} + l*${15}))
      ll=$((i*$4 + j*$8 + k*${12} + l*${16}))
   mm=$((m*$1 + n*$5 + o*$9    + p*${13}))
    nn=$((m*$2 + n*$6 + o*${10} + p*${14}))
     oo=$((m*$3 + n*$7 + o*${11} + p*${15}))
      pp=$((m*$4 + n*$8 + o*${12} + p*${16}))
   if ((16==$#)); then echo $aa $bb $cc $dd $ee $ff $gg $hh $ii $jj $kk $ll $mm $nn $oo $pp; return; fi
   shift 16
   a=$((aa*$1 + bb*$5 + cc*$9    + dd*${13}))
    b=$((aa*$2 + bb*$6 + cc*${10} + dd*${14}))
     c=$((aa*$3 + bb*$7 + cc*${11} + dd*${15}))
      d=$((aa*$4 + bb*$8 + cc*${12} + dd*${16}))
   e=$((ee*$1 + ff*$5 + gg*$9    + hh*${13}))
    f=$((ee*$2 + ff*$6 + gg*${10} + hh*${14}))
     g=$((ee*$3 + ff*$7 + gg*${11} + hh*${15}))
      h=$((ee*$4 + ff*$8 + gg*${12} + hh*${16}))
   i=$((ii*$1 + jj*$5 + kk*$9    + ll*${13}))
    j=$((ii*$2 + jj*$6 + kk*${10} + ll*${14}))
     k=$((ii*$3 + jj*$7 + kk*${11} + ll*${15}))
      l=$((ii*$4 + jj*$8 + kk*${12} + ll*${16}))
   m=$((mm*$1 + nn*$5 + oo*$9    + pp*${13}))
    n=$((mm*$2 + nn*$6 + oo*${10} + pp*${14}))
     o=$((mm*$3 + nn*$7 + oo*${11} + pp*${15}))
      p=$((mm*$4 + nn*$8 + oo*${12} + pp*${16}))
   if ((16==$#)); then echo $a $b $c $d $e $f $g $h $i $j $k $l $m $n $o $p; return; fi
   shift 16
 done
} # matMultNTrans 

assertEquals matMultNTrans \
 "$(matMultNTrans 2 0 0 0  0 3 0 0  0 0 4 0  0 0 0 5 \
                 2 3 4 5  9 8 7 6  3 9 7 5  8 2 4 6 \
                 0 0 0 1  0 0 1 0  0 1 0 0  1 0 0 0)" \
 "$(echo '10 8 6 4 18 21 24 27 20 28 36 12 30 20 10 40')"
assertEquals matMultNTrans \
 "$(matMultNTrans 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17   2 3 4 5  6 7 8 9  10 11 12 13  14 15 16 17)" \
 "$(echo '132 146 160 174 260 290 320 350 388 434 480 526 516 578 640 702')"



# This isn't any faster.  Expects &mat and N matrices passed symbolically expanded.
function matMultXformLocal () { # &mat
 local a b c d
 while :; do
   a=${mat[0]}
   b=${mat[1]}
   c=${mat[2]}
   d=${mat[3]}
   mat[0]=$((a*$1 + b*$5 + c*$9    + d*${13}))
    mat[1]=$((a*$2 + b*$6 + c*${10} + d*${14}))
     mat[2]=$((a*$3 + b*$7 + c*${11} + d*${15}))
      mat[3]=$((a*$4 + b*$8 + c*${12} + d*${16}))
   a=${mat[4]}
   b=${mat[5]}
   c=${mat[6]}
   d=${mat[7]}
   mat[4]=$((a*$1 + b*$5 + c*$9    + d*${13}))
    mat[5]=$((a*$2 + b*$6 + c*${10} + d*${14}))
     mat[6]=$((a*$3 + b*$7 + c*${11} + d*${15}))
      mat[7]=$((a*$4 + b*$8 + c*${12} + d*${16}))
   a=${mat[8]}
   b=${mat[9]}
   c=${mat[10]}
   d=${mat[11]}
   mat[8]=$((a*$1 + b*$5 + c*$9    + d*${13}))
    mat[9]=$((a*$2 + b*$6 + c*${10} + d*${14}))
     mat[10]=$((a*$3 + b*$7 + c*${11} + d*${15}))
      mat[11]=$((a*$4 + b*$8 + c*${12} + d*${16}))
   a=${mat[12]}
   b=${mat[13]}
   c=${mat[14]}
   d=${mat[15]}
   mat[12]=$((a*$1 + b*$5 + c*$9    + d*${13}))
    mat[13]=$((a*$2 + b*$6 + c*${10} + d*${14}))
     mat[14]=$((a*$3 + b*$7 + c*${11} + d*${15}))
      mat[15]=$((a*$4 + b*$8 + c*${12} + d*${16}))
   ((32<=$#)) && return
   shift 16
 done
}


function matMultTransVecNormalized { # &mi &vx &vy &vz &vn => &x &y &z
  local n
  ((n=mattrans[mi+12]*vx+mattrans[mi+13]*vy+mattrans[mi+14]*vz+mattrans[mi+15]*vn))
  ((x=(mattrans[mi+0]*vx+mattrans[mi+1]*vy+mattrans[mi+2]*vz+mattrans[mi+3]*vn)/n))
  ((y=(mattrans[mi+4]*vx+mattrans[mi+5]*vy+mattrans[mi+6]*vz+mattrans[mi+7]*vn)/n))
  ((z=(mattrans[mi+8]*vx+mattrans[mi+9]*vy+mattrans[mi+10]*vz+mattrans[mi+11]*vn)/n))
}


##
## _Matrices_
##
matstat=(1 0 0 0  0 1 0 0  0 0 1 0  0 0 0 1) # Static list of matrices.  First one is the global transform matrix.  Starts off as identity and is mutated.
mattrans=(1 0 0 0  0 1 0 0  0 0 1 0  0 0 0 1) # Transformed (by the global mat) matrices.  Recalculated every frame.

function matAppend { # => &ret
  local len=${#matstat[*]}
  ret=$((len/16)) # keep track of the starting vector index
  while ((16<=$#)); do
    matstat[len+0]=$1;     matstat[len+1]=$2;     matstat[len+2]=$3;     matstat[len+3]=$4
    matstat[len+4]=$5;     matstat[len+5]=$6;     matstat[len+6]=$7;     matstat[len+7]=$8
    matstat[len+8]=$9;     matstat[len+9]=${10};  matstat[len+10]=${11}; matstat[len+11]=${12}
    matstat[len+12]=${13}; matstat[len+13]=${14}; matstat[len+14]=${15}; matstat[len+15]=${16}
    shift 16
    ((len+=16))
   done
}

function matSet { # &len
  local x=$(($1*16)) # start at matrix index $1
  matstat[x+0]=$2;     matstat[x+1]=$3;     matstat[x+2]=$4;     matstat[x+3]=$5
  matstat[x+4]=$6;     matstat[x+5]=$7;     matstat[x+6]=$8;     matstat[x+7]=$9
  matstat[x+8]=${10};  matstat[x+9]=${11};  matstat[x+10]=${12}; matstat[x+11]=${13}
  matstat[x+12]=${14}; matstat[x+13]=${15}; matstat[x+14]=${16}; matstat[x+15]=${17}
}

function matSetGlobal { # &len
  (( $# % 17 )) && { >&2 echo "eatSetGlobal has not mod 17 args: [$*]"; }
  local x=$(($1*16)) # start at matrix index $1
  matstat[x+0]=$2;     matstat[x+1]=$3;     matstat[x+2]=$4;     matstat[x+3]=$5
  matstat[x+4]=$6;     matstat[x+5]=$7;     matstat[x+6]=$8;     matstat[x+7]=$9
  matstat[x+8]=${10};  matstat[x+9]=${11};  matstat[x+10]=${12}; matstat[x+11]=${13}
  matstat[x+12]=${14}; matstat[x+13]=${15}; matstat[x+14]=${16}; matstat[x+15]=${17}

  mattrans[x+0]=$2;     mattrans[x+1]=$3;     mattrans[x+2]=$4;     mattrans[x+3]=$5
  mattrans[x+4]=$6;     mattrans[x+5]=$7;     mattrans[x+6]=$8;     mattrans[x+7]=$9
  mattrans[x+8]=${10};  mattrans[x+9]=${11};  mattrans[x+10]=${12}; mattrans[x+11]=${13}
  mattrans[x+12]=${14}; mattrans[x+13]=${15}; mattrans[x+14]=${16}; mattrans[x+15]=${17}
}

# Multiply every static matrix matstat[*] with the global matrix matstat[0] into the mattrans array
function matTransformStatic { # &mat &matstat $mattrans
 local a=${matstat[0]} b=${matstat[1]} c=${matstat[2]} d=${matstat[3]} e=${matstat[4]} f=${matstat[5]} g=${matstat[6]} h=${matstat[7]} i=${matstat[8]} j=${matstat[9]} k=${matstat[10]} l=${matstat[11]} m=${matstat[12]} n=${matstat[13]} o=${matstat[14]} p=${matstat[15]} aa bb cc dd ee ff gg hh ii jj kk ll mm nn oo pp
 local x=0 max=${#matstat[*]}
 while (((x+=16)<max)); do
   aa=${matstat[x+0]}  bb=${matstat[x+1]}  cc=${matstat[x+2]}  dd=${matstat[x+3]}
   ee=${matstat[x+4]}  ff=${matstat[x+5]}  gg=${matstat[x+6]}  hh=${matstat[x+7]}
   ii=${matstat[x+8]}  jj=${matstat[x+9]}  kk=${matstat[x+10]} ll=${matstat[x+11]}
   mm=${matstat[x+12]} nn=${matstat[x+13]} oo=${matstat[x+14]} pp=${matstat[x+15]}
   mattrans[x+0]=$((a*aa + b*ee + c*ii + d*mm))
   mattrans[x+1]=$((a*bb + b*ff + c*jj + d*nn))
   mattrans[x+2]=$((a*cc + b*gg + c*kk + d*oo))
   mattrans[x+3]=$((a*dd + b*hh + c*ll + d*pp))

   mattrans[x+4]=$((e*aa + f*ee + g*ii + h*mm))
   mattrans[x+5]=$((e*bb + f*ff + g*jj + h*nn))
   mattrans[x+6]=$((e*cc + f*gg + g*kk + h*oo))
   mattrans[x+7]=$((e*dd + f*hh + g*ll + h*pp))

   mattrans[x+8]=$(( i*aa + j*ee + k*ii + l*mm))
   mattrans[x+9]=$(( i*bb + j*ff + k*jj + l*nn))
   mattrans[x+10]=$((i*cc + j*gg + k*kk + l*oo))
   mattrans[x+11]=$((i*dd + j*hh + k*ll + l*pp))

   mattrans[x+12]=$((m*aa + n*ee + o*ii + p*mm))
   mattrans[x+13]=$((m*bb + n*ff + o*jj + p*nn))
   mattrans[x+14]=$((m*cc + n*gg + o*kk + p*oo))
   mattrans[x+15]=$((m*dd + n*hh + o*ll + p*pp))
 done
}

function matDump {
  local i=0 v
  local count=$((${#matstat[*]}/16))
  for i in $(range 0 $((count - 1))); do
    echo "-- matrix static $i ----"
    dm4 ${matstat[*]:i*16:16}
  done
}

function matTransDump {
  local i=0 v
  local count=$((${#mattrans[*]}/16))
  for i in $(range 0 $((count - 1))); do
    echo "-- matrix transformed $i ----"
    dm4 ${mattrans[*]:i*16:16}
  done
}

assertEquals matstat1 \
 "$(matAppend {1..16}
    dv ${matstat[*]})" \
 "$(echo '[  1   0   0   0 ]'
    echo '[  0   1   0   0 ]'
    echo '[  0   0   1   0 ]'
    echo '[  0   0   0   1 ]'
    echo '[  1   2   3   4 ]'
    echo '[  5   6   7   8 ]'
    echo '[  9  10  11  12 ]'
    echo '[ 13  14  15  16 ]')"
assertEquals matstat2 \
 "$(matSetGlobal 1 {0..15}
    dv ${matstat[*]})" \
 "$(echo '[  1   0   0   0 ]'
    echo '[  0   1   0   0 ]'
    echo '[  0   0   1   0 ]'
    echo '[  0   0   0   1 ]'
    echo '[  0   1   2   3 ]'
    echo '[  4   5   6   7 ]'
    echo '[  8   9  10  11 ]'
    echo '[ 12  13  14  15 ]')"
assertEquals matTransformStatic \
 "$(matSetGlobal 0  2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17
    matAppend 1 0 0 0  0 1 0 0  0 0 1 0  0 0 0 1
    matAppend 0 0 0 1  0 0 1 0  0 1 0 0  1 0 0 0
    matAppend 2 3 4 5  6 7 8 9  10 11 12 13  14 15 16 17
    matTransformStatic
    matTransDump)" \
 "$(echo '-- matrix transformed 0 ----'
    echo '[        2         3         4         5]'
    echo '[        6         7         8         9]'
    echo '[       10        11        12        13]'
    echo '[       14        15        16        17]'
    echo
    echo '-- matrix transformed 1 ----'
    echo '[        2         3         4         5]'
    echo '[        6         7         8         9]'
    echo '[       10        11        12        13]'
    echo '[       14        15        16        17]'
    echo
    echo '-- matrix transformed 2 ----'
    echo '[        5         4         3         2]'
    echo '[        9         8         7         6]'
    echo '[       13        12        11        10]'
    echo '[       17        16        15        14]'
    echo
    echo '-- matrix transformed 3 ----'
    echo '[      132       146       160       174]'
    echo '[      260       290       320       350]'
    echo '[      388       434       480       526]'
    echo '[      516       578       640       702]')"
##
#### _Matrices_


# Given index into vectors array (... x y z n   x' y' z' n'   x" y" z" n" ...), which define two vectors starting at x y z, and
# index into matrix transform array, the transform to apply to the normal plane,
# Return true if the normal is facing viewer
# Completely inlined matrix multiply and normal calculation with z-component optimization
function isPlaneFacing { # (idxVectors idxMatrices)
  (( $# % 2 )) && { echo "isPlaneFacing has not mod 2 args: $*"; exit -1; }
  local vi=$((4*$1)) vx vy vz vn n x0 y0 x1 y1 x2 y2
  local mi=$((16*$2))
  vx=${vectors[vi]}
  vy=${vectors[vi+1]}
  vz=${vectors[vi+2]}
  vn=${vectors[vi+3]}
  n=$((mattrans[mi+12]*vx+mattrans[mi+13]*vy+mattrans[mi+14]*vz+mattrans[mi+15]*vn))
  (( n == 0 )) && { echo "n=0=${mattrans[mi+12]}\*$vx+${mattrans[mi+13]}\*$vy+${mattrans[mi+14]}\*$vz+${mattrans[mi+15]}\*$vn"; }
  x0=$((4*(mattrans[mi+0]*vx+mattrans[mi+1]*vy+mattrans[mi+2]*vz+mattrans[mi+3]*vn)/n))
  y0=$((4*(mattrans[mi+4]*vx+mattrans[mi+5]*vy+mattrans[mi+6]*vz+mattrans[mi+7]*vn)/n))
  vx=${vectors[vi+4]}
  vy=${vectors[vi+5]}
  vz=${vectors[vi+6]}
  vn=${vectors[vi+7]}
  n=$((mattrans[mi+12]*vx+mattrans[mi+13]*vy+mattrans[mi+14]*vz+mattrans[mi+15]*vn))
  x1=$((4*(mattrans[mi+0]*vx+mattrans[mi+1]*vy+mattrans[mi+2]*vz+mattrans[mi+3]*vn)/n))
  y1=$((4*(mattrans[mi+4]*vx+mattrans[mi+5]*vy+mattrans[mi+6]*vz+mattrans[mi+7]*vn)/n))
  vx=${vectors[vi+8]}
  vy=${vectors[vi+9]}
  vz=${vectors[vi+10]}
  vn=${vectors[vi+11]}
  n=$((mattrans[mi+12]*vx+mattrans[mi+13]*vy+mattrans[mi+14]*vz+mattrans[mi+15]*vn))
  x2=$((4*(mattrans[mi+0]*vx+mattrans[mi+1]*vy+mattrans[mi+2]*vz+mattrans[mi+3]*vn)/n))
  y2=$((4*(mattrans[mi+4]*vx+mattrans[mi+5]*vy+mattrans[mi+6]*vz+mattrans[mi+7]*vn)/n))
  (( (x1-x0)*(y2-y0)-(y1-y0)*(x2-x0) < 0 ))
}

function plotLines () { # &oi &cl &ch &last &mat
  local idx=$oi vi vx vy vz vn a b c x y z
  while ((idx<last)); do # over every vector index in object
    vi=${objects[idx]}
    vx=${vectors[$vi*4]}
    vy=${vectors[$vi*4+1]}
    vz=${vectors[$vi*4+2]}
    vn=${vectors[$vi*4+3]}
    matMultTransVecNormalized # &mat &vx &vy &vz &vn => &x &y &z &n
    a=$x
    b=$y
    c=$z
    vi=${objects[idx+1]}
    vx=${vectors[$vi*4]}
    vy=${vectors[$vi*4+1]}
    vz=${vectors[$vi*4+2]}
    vn=${vectors[$vi*4+3]}
    matMultTransVecNormalized # &mat &vx &vy &vz &vn => &x &y &z &n
    terminalDrawLine $c $b $a $z $y $x $cl $ch
    ((idx+=2))
  done
}

function plotPoly () { # &cl &ch &oi &last
  local idx=$oi vi vx vy vz vn ox oy oz on lx ly lz x y z
  # Keep track of first point
  vi=${objects[idx]}
  vx=${vectors[$vi*4]}
  vy=${vectors[$vi*4+1]}
  vz=${vectors[$vi*4+2]}
  vn=${vectors[$vi*4+3]}
  matMultTransVecNormalized # &mat &vx &vy &vz &vn => &x &y &z &n
  ox=$x
  oy=$y
  oz=$z
  lx=$ox
  ly=$oy
  lz=$oz
  ((++idx))
  while ((idx<last)); do # over every vector index in object
    vi=${objects[idx]}
    vx=${vectors[$vi*4]}
    vy=${vectors[$vi*4+1]}
    vz=${vectors[$vi*4+2]}
    vn=${vectors[$vi*4+3]}
    matMultTransVecNormalized # &mat &vx &vy &vz &vn => &x &y &z &n
    terminalDrawLine  $lz $ly $lx $z $y $x $cl $ch
    lx=$x
    ly=$y
    lz=$z
    ((++idx))
  done
  terminalDrawLine  $z $y $x $oz $oy $ox $cl $ch
}

function plotPoints () { # &oi &cl &ch &last &mi
  local idx=$oi vi vx vy vz vn x y zn
  while ((idx<last)); do # over every vector index in object
    vi=${objects[idx]} # Vector index in vectors array
    vx=${vectors[$vi*4]}
    vy=${vectors[$vi*4+1]}
    vz=${vectors[$vi*4+2]}
    vn=${vectors[$vi*4+3]}
    matMultTransVecNormalized # &mi &vx &vy &vz &vn => &x &y &z
    terminalIsInScreen $x $y && echo $((x+TWIDTH2)) $((y+THEIGHT2)) $z $cl $ch
    ((++idx))
  done
}



##
## _Globals_
##
powerButton=true
frame=0
framestop=60
sigwinch=false



##
## _Rendering_ and Scheduling
##
screenBufferEmpty=""
depthBufferEmpty=""

function resetEmptyBuffers {
  screenBufferEmpty="$(printf "%.s' ' "  $(range 1 $((TWIDTH*THEIGHT))))"
  depthBufferEmpty="$(printf "%.s9999 " $(range 1 $((TWIDTH*THEIGHT))))"
}

function renderObjectSet { # &oil &frame &thread
  #trap : INT
  local oi type cl ch count last mi
  for oi in ${oil[*]}; do
    type=${objects[oi+1]}
    cl=${objects[oi+2]}
    ch=${objects[oi+3]}
    mi=$((16*${objects[oi+4]}))
    count=${objects[oi+6]}
    ((oi+=7))
    ((last=oi+count)) # compute index of last element in this object
    case $type in # &cl &ch &oi &last &mi
      (p) plotPoints ;;
      (l) plotLines ;;
      (y) plotPoly ;;
    esac
  done
  echo "q"
} >"${frame}_$thread"

function scheduleObjectRenderers { # &frame !&thread
  local max=${#objects[*]} oi=0 oil=() oilc=0 
  # over all objects
  while ((oi<max)); do
    #symbol=${objects[oi+0]}
    type=${objects[oi+1]}
    cl=${objects[oi+2]}
    ch=${objects[oi+3]}
    plane=${objects[oi+5]}
    count=${objects[oi+6]}
    oi=$((oi+7))
    last=$((count + oi)) # compute index of last element in this object
    if ((0==${facing[plane]})); then
      oil[oilc]=$((oi-7))
      ((++oilc))
      if ((8<oilc)); then # more things happen per thread the higher this number is
        ((++thread))
        { setAllTraps renderObjectSet_frame$frame; renderObjectSet; } & # &oil &frame &thread
        oil=()
        oilc=0
      fi
    fi
    oi=$last # Skip object index to next object in array
  done

  if ((0<oilc)); then # Run any threads in the partially full list
    ((++thread))
    { setAllTraps renderObjectSet_frame$frame; renderObjectSet; } & # &oil &frame &thread
  fi
}


function doNormals { # &mat
  local i=2 # skip the first two fixed normal bools
  local max=$(planesLength)
  while ((i<max)); do
    isPlaneFacing ${planes[i*2]} ${planes[i*2+1]}
    facing[i]=$?
    ((++i))
  done
}

function fillDepthBuffer { # &frame &thread &screenBuffer &depthBuffer
  # clear the screen buffer
  local idx x y z k c i=0 # TODO is i used?
  for filename in $(prerange ${frame}_ 1 $thread); do

    while [ ! -e $filename ]; do
      >&2 echo "ERROR: fillDepthBuffer: $filename doesn't exist frame$frame."
      sleep .1
      ((++spin))
    done # spin until the file is created

    while :; do
      read x y z k c
      #>&2 printf "read frame$frame '$x' '$y' '$z' '$k' '$c'\n"
      [ "$x" == q ] && break
      [ ${#c} != 1 ] && { printf "::fillDepthBuffer read a bad thing ['$x' '$y' '$z' '$k' '$c'] frame$frame\n"; kill -9 $moi; exit -1; }
      if [ -z "$c" ]; then
        <&2 echo "ERROR: only read from $filename ':$x :$y :$z :$k :$c'"
        sleep 1
        ((++spin))
        continue
      fi
      ((idx=x+y*TWIDTH))
      if ((z < depthBuffer[idx])); then
        screenBuffer[idx]="[${COLORS[k]}m$c"
        depthBuffer[idx]=$z
      fi
    done <"$filename"

    while ! rm $filename; do # Remove the files the rendering processes created
      echo "cant delete file $filename in fillDepthBuffer frame$frame"
    done

    ((++i))
  done
}

function dumpStats { #&thread &spin
  # parent: facing thread
  if [ $SECONDS -ne 0 ]; then
    frameRate=$((100*frame/(SECONDS)))
    PC 8 "frame:$frame\nfps:$((frameRate/100)).$((frameRate%100))\nthreads:$thread\nspins:$spin"
  fi
}

ux=0
uy=12
uz=0
ur=0
function renderFrame {
  local thread=0 screenBuffer depthBuffer spin=0 matrixPerspective
  #[ $sec == 0 ] || [ "$1" == -resetCritters ] && resetCritters # Animal glyphs reset every minute or screen resize. 
  #matrixPerspective="$matIdent"

#>&2 printf "\n\e[32m    ::${frame}renderFrame\e[0m\n"

#>&2 printf "\e[32m      ${frame} compute perspective...\e[0m\n"
  matrixPerspective=$(
    setAllTraps ${frame}renderFrameA
    matMultNTrans $(
      setAllTraps ${frame}renderFrameB
      matPerspective 80
      matTrans 0 0 90
      matScale 1 1 1
    )
  )

#>&2 printf "\e[32m      ${frame} compute set global matrix...\e[0m\n"

  #matSetGlobal 0 $(matMultNTrans $matrixPerspective $(matTrans 0 0 $((  (frame % 100 - 50) * (frame % 100 - 15) - 100 )) )) # Broken zoon
  matSetGlobal 0 $(
    setAllTraps renderFrame2_frame$frame
    #trap : INT
    matMultNTrans $matrixPerspective $(
      setAllTraps renderFrame3_frame$frame
      #trap : INT
      matRotz $frame
      matRotx -8
      matRoty $frame
      #matRoty "$ur"
      #matTrans $ux $uy $uz
    )
  )

#>&2 printf "\e[32m      ${frame} check thread count...\e[0m\n"

  # Block on too many render-frame threads
  while [ -e frame$((frame-6)) ]; do
    #>&2 echo "${frame}renderFrame 
    sleep .01
  done

#>&2 printf "\e[32m      ${frame} forking rendererThread\e[0m\n"

  { # Fork
    setAllTraps renderFrame4_frame$frame
#>&2 printf "\n\e[1;36m      ::${frame}rendererThread\e[0m"
    #trap : INT
    matTransformStatic
    doNormals
    scheduleObjectRenderers # &frame &thread -- Creates files with "x y z k c" per line
    if ((0!=thread)); then # if any rendering threads exist...
      eval screenBuffer=($screenBufferEmpty)
      depthBuffer=($depthBufferEmpty)
      fillDepthBuffer # &frame &thread &screenBuffer &depthBuffer &spin
      # Wait for sentinel to appear from previous frame's rendering thread
      while [ ! -e frame$((frame-1)) ]; do sleep .02$frame; done #TODO this gets stuck sometimes
      IFS=''
        printf "\e[0H${screenBuffer[*]}\e[$((THEIGHT-4))H$(dumpStats)" # &thread &spin
        #>&2 printf " \e[1;36m($frame screenBuffer > STDOUT)\e[0m "
        touch frame$frame # Tell next thread it can render to the screen now
      unset IFS
      waitThenDelete frame$((frame-1)) "renderFrame_frame$frame" .03
    else
      touch frame$frame # Tell next thread it can render to the screen now
      waitThenDelete frame$((frame-1)) "renderFrame_else_frame$frame" .04
    fi
#>&2 printf "\n\e[1;36m      --${frame}rendererThread\e[0m"
  } &

#>&2 printf "\e[32m    --${frame}renderFrame\e[0m\n"
} #renderFrame 


##
## _Build_ Models
##
ret=0
clockMid=0
clockIdx=0
clockRadius=10
matAppend $matIdent;  clockMid=$ret
function buildClock {
  local r=$1 s=$((- $1)) face=$2 tr idx nidx ret
  local b=$((r+0))
  shift 2
  clockRadius=$r
  case $face in
   (0) tr=$(matMultNTrans $(matRoty  0) $(matTrans 0 0 -$b)) ;;
   (1) tr=$(matMultNTrans $(matRoty 30) $(matTrans 0 0 -$b)) ;;
   (2) tr=$(matMultNTrans $(matRoty 60) $(matTrans 0 0 -$b)) ;;
   (3) tr=$(matMultNTrans $(matRoty 90) $(matTrans 0 0 -$b)) ;;
   (4) tr=$(matMultNTrans $(matRotx 30) $(matTrans 0 0 -$b)) ;;
   (5) tr=$(matMultNTrans $(matRotx 90) $(matTrans 0 0 -$b)) ;;
  esac

  # plane vectors for normal calculatoin.
  # The first three vectors will be used to calculate the culling normal for the entire clock.
  vectorsAppend  $(matMultTransNVec $tr  0 0 0 1   $r 0 0 1   0 $s 0 1)
  vidx=$ret # The index to these vectors is used a bunch of times
  planesAppend $vidx $clockMid # Register the vectors index of these three points
  pidx=$ret # Keep track of this plane's index as it's used by all the objects on this plane

  vectorsAppend  $(matMultTransNVec $tr  0 $s 0 1   $r 0 0 1   $r $r 0 1)
  objectsAdd HOUR l 6 _  $clockMid $pidx $vidx $((ret))
  objectsAdd MIN  l 2 _  $clockMid $pidx $vidx $((ret+1))
  objectsAdd SEC  l 5 _  $clockMid $pidx $vidx $((ret+2))

  vectorsAppend  $(matMultTransNVec $tr  $s $s 0 1  $r $s 0 1   $r $r 0 1  $s $r 0 1 )
  objectsAdd BOX  y 15 @ $clockMid $pidx $((ret)) $((ret+1)) $((ret+2)) $((ret+3))

  for s in 10 20 30 40 50 60 70 80 90 100 110; do
    vectorsAppend $(matMultTransNVec $(matMultNTrans $tr $(matRotz $s))  0 $((r/2)) 0 1   0 $r 0 1)
    objectsAdd TICK l 7 . $clockMid $pidx $ret $((ret + 1))
  done
}

function updateClock {
  #timeProbe # $((frame*483))
  #vectors[(clockIdx+3)*4+0]=$((COSTABLE[(hour+90)%120]*clockRadius/240))
  #vectors[(clockIdx+3)*4+1]=$((SINTABLE[(hour+90)%120]*clockRadius/240))
  #vectors[(clockIdx+4)*4+0]=$((COSTABLE[(min+90)%120]*clockRadius/120))
  #vectors[(clockIdx+4)*4+1]=$((SINTABLE[(min+90)%120]*clockRadius/120))
  #vectors[(clockIdx+5)*4+0]=$((COSTABLE[(sec+90)%120]*clockRadius/120))
  #vectors[(clockIdx+5)*4+1]=$((SINTABLE[(sec+90)%120]*clockRadius/120))
  matSet $clockMid $(matRoty -$frame)
}




function buildTexturedCubes {
  local r=$1 # radius of the cubes
  local s=$2 # distance between cubes
  local d=$3 # density of the cubes
  local ret vidx0 vidx1 vidx2 vidx3 vidx4 vidx5

  # Generate the plane and textured points
  local  x  y=$((-r/d-0)) i=12
  local tf=($y $y 0 1   $y $((r/d-1)) 0 1   $((r/d-1)) $y 0 1) # normal plane
  while ((y <= r/d)); do
    x=$((-r/d-0))
    while ((x <= r/d)); do
      tf[i]=$((d*x))
      tf[i+1]=$((d*y))
      tf[i+2]=0
      tf[i+3]=1
      i=$((i+4))
      x=$((x+1))
    done
    y=$((y+1))
  done

  local tflen=$((${#tf[*]}/4))

  # Generate and register the vertices of each face forming the box model
  vectorsAppend $(matMultTransNVec $(matMultNTrans $(matRoty  0) $(matTrans 0 0 -$r)) ${tf[*]}); vidx0=$ret
  vectorsAppend $(matMultTransNVec $(matMultNTrans $(matRoty 30) $(matTrans 0 0 -$r)) ${tf[*]}); vidx1=$ret
  vectorsAppend $(matMultTransNVec $(matMultNTrans $(matRoty 60) $(matTrans 0 0 -$r)) ${tf[*]}); vidx2=$ret
  vectorsAppend $(matMultTransNVec $(matMultNTrans $(matRoty 90) $(matTrans 0 0 -$r)) ${tf[*]}); vidx3=$ret
  vectorsAppend $(matMultTransNVec $(matMultNTrans $(matRotx 30) $(matTrans 0 0 -$r)) ${tf[*]}); vidx4=$ret
  vectorsAppend $(matMultTransNVec $(matMultNTrans $(matRotx 90) $(matTrans 0 0 -$r)) ${tf[*]}); vidx5=$ret

  function buildTexturedCube { # (midx)
    local midx=$1
    local ret # the transformation matrix index for the normal plane
    planesAppend $vidx0 $midx
    objectsAdd FACE0 p 1 @ $midx $ret $(range $((vidx0+3)) $((vidx0+$tflen-1)))
    planesAppend $vidx1 $midx
    objectsAdd FACE1 p 2 @ $midx $ret $(range $((vidx1+3)) $((vidx1+$tflen-1)))
    planesAppend $vidx2 $midx
    objectsAdd FACE2 p 3 @ $midx $ret $(range $((vidx2+3)) $((vidx2+$tflen-1)))
    planesAppend $vidx3 $midx
    objectsAdd FACE3 p 4 @ $midx $ret $(range $((vidx3+3)) $((vidx3+$tflen-1)))
    planesAppend $vidx4 $midx
    objectsAdd FACE4 p 5 @ $midx $ret $(range $((vidx4+3)) $((vidx4+$tflen-1)))
    planesAppend $vidx5 $midx
    objectsAdd FACE5 p 6 @ $midx $ret $(range $((vidx5+3)) $((vidx5+$tflen-1)))
  }

  # These 6 matrices will affect each of the cube objects
  matAppend $(matTrans -$s 10   0);  mymat=$ret;  buildTexturedCube $ret
  matAppend $(matTrans   0 10  $s);  buildTexturedCube $ret
  matAppend $(matTrans   0 10 -$s);  buildTexturedCube $ret
  matAppend $(matTrans  $s 10   0);  buildTexturedCube $ret
  mys=$s
} # buildTexturedCubes

mys=20
mymat=2
function updateBoxes {
  matSet $((mymat+0)) $(matMultNTrans $(matTrans -25  25  0) $(matRoty $((frame*4))) $(matRotx $((frame*1))))
  matSet $((mymat+1)) $(matMultNTrans $(matTrans 25  -25  0) $(matRoty $((frame*3))) $(matRotx $((frame*2))))
  matSet $((mymat+2)) $(matMultNTrans $(matTrans -25 -25  0) $(matRoty $((frame*2))) $(matRotx $((frame*3))))
  matSet $((mymat+3)) $(matMultNTrans $(matTrans 25  25   0) $(matRoty $((frame*1))) $(matRotx $((frame*4))))
}


function buildFloor {
  local ret
  local r=$1 # radius of the cubes
  local s=$2 # floor height
  local d=$3 # density of the cubes

  function buildTexturedFace {
    local  x  z=$((-r/d))
    while ((z <= r/d)); do
      x=$((-r/d))
      while ((x <= r/d)); do
        echo -n "$((d*x)) 0 $((d*z)) 1 "
        x=$((x+1))
      done
      z=$((z+1))
    done
  }
  vectorsAppend $(matMultTransNVec $(matTrans 0 $s 0) $(buildTexturedFace))
  objectsAdd FLOOR p 8 @ 0 1 $(range $((ret)) $((ret + $(vectorsLength) - ret - 1)))
}

function buildLines {
  local ret
  local r=$1 # radius of the cubes
  local s=$2 # floor height
  local d=$3 # density of the cubes

  function buildTexturedFace {
    local x z
    ((z=-r/d))
    while ((z <= r/d)); do
      x=$((-r/d))
      while ((x <= r/d)); do
        vectorsAppend $(matMultTransNVec $(matTrans 0 $s 0) $((d*x)) 0 $((d*z)) 1    $((d*x)) -30 $((d*z)) 1 )
        objectsAdd FLOOR l $((RANDOM%16)) @ 0 1 $(range $ret $((ret+1)) )
        ((++x))
      done
      ((++z))
    done
  }
  buildTexturedFace 
}



function buildSimpleBox {
  # (1) Create the points
  local ret r=$1 cl=$2 ch=$3 idx mymat
  matAppend $(matTrans 0 0 0);  mymat=$ret
  vectorsAppend -$r $r $r 1  $r $r $r 1  $r -$r $r 1  -$r -$r $r 1   -$r $r -$r 1  $r $r -$r 1  $r -$r -$r 1  -$r -$r -$r 1
  #objectsAdd POINTS p 3 x $mymat 1  $(range $ret $((ret+7)))
  objectsAdd BOX   y $cl $ch $mymat 1  $(range $ret $((ret+3)))  # back
  objectsAdd BOX   y $cl $ch $mymat 1  $(range $((ret+4)) $((ret+7)))  # front
  objectsAdd EDGES l $cl $ch $mymat 1  $((ret+1)) $((ret+5))  $((ret+2)) $((ret+6))  $((ret+3)) $((ret+7))  $((ret+4)) $ret
  #r=$((r/2))
  #vectorsAppend -$r $r $r 1  $r $r $r 1  $r -$r $r 1  -$r -$r $r 1   -$r $r -$r 1  $r $r -$r 1  $r -$r -$r 1  -$r -$r -$r 1
  #objectsAdd POINTS y 2 y $mymat 1  $(range $((ret+0)) $((ret+7)))
}

function buildUrchin {
  local origin ret c=$1 r=$2 glyphs=('.' '+' '@' 'x' 'o' '-')

  while ((0<c)); do
    vectorsAppend $(matMultTransNVec $(matMultNTrans $(matTrans 0 0 0) $(matRotx $((RANDOM%120))) $(matRoty $((RANDOM%120))) $(matRotz $((RANDOM%120))) ) $((r/2)) 0 0 1 $r 0 0 1)
    objectsAdd LINE l $((RANDOM%15+1)) ${glyphs[c%6]} 0 1 $ret $((ret+1))
   c=$((c-1))
  done
}


# bash
function setAllTraps2 {
  for s in {1..64}; do
    trap ">&2 echo '($1_sig$s)'" $s
  done
}

function setAllTraps {
  trap ">&2 echo '($1_sig2)'" 2
}


##
## Exception handlers
##
function handler_sigint { echo "++${frame}handler_sigint [${FUNCNAME[*]}]"; powerButton=false; }
function handler_sigwinch { sigwinch=true; }

##
## USAGE:  basciiclock [a|b] {frame count}
##
function main {
  framestop=${1:--1}
  setAllTraps main
  trap handler_sigint  PIPE INT QUIT TERM
  trap handler_sigwinch WINCH
  printf "\e[?25l\e[0m" # Disable cursor
  >&2 printf "\e[31m::${frame}main\e[0m"
  terminalProbe
  resetEmptyBuffers
  resetCritters

  #buildUrchin 50 90
  #buildSimpleBox 15 1 @
  #buildSimpleBox 25 2 @
  #buildSimpleBox 35 4 @
  #buildSimpleBox 45 5 @
  #buildTexturedCubes 10 80 5
  #buildFloor 80 0  8
  #buildLines 60 0 30
  if  :; then
    buildClock 40 0
    buildClock 40 1
    buildClock 40 2
    buildClock 40 3
    buildClock 40 4
    buildClock 40 5
  fi
  #vectorsDump
  #objectsDump
  #planesDump
  #matDump
  #read -n 1 -p 'Abort, Retry, Fail?' k
  touch frame$frame # Sentinel so the first frame will render
  moi=$$

  function handleUSR1 {
    ((++frame, ++ur))
    #>&2 printf "\n\e[31m  ::${frame}handleUSR1\e[0m"
    if $powerButton; then
      if $sigwinch; then
        echo handler
        wait
        terminalProbe
        resetEmptyBuffers
        sigwinch=false
      fi
      #>&2 printf "\n\e[31m    ${frame}handleUSR1 call renderFrame...\e[0m"
      renderFrame
      #updateClock
      #updateBoxes
      {
        setAllTraps renderFrame2_frame$frame
        #>&2 printf "\n\e[1;31m      ${frame}scheduleInterrupt sleep\e[0m"
        sleep .01
        #>&2 printf "\n\e[1;31m      ${frame}scheduleInterrupt kill -USR1\e[0m"
        kill -USR1 $moi
        #>&2 printf "\n\e[1;31m    --${frame}scheduleInterrupt!!!!!!!!!!!!!!!!!!!!!!!!\e[0m"
      } &
      #>&2 printf "\n\e[1;31m    ::${frame}scheduleInterrupt (forked $!)\e[0m"
      #>&2 printf "\n\e[31m  --${frame}handleUSR1\e[0m"
    #else
      #>&2 printf "\n\e[31m  --${frame}handleUSR1 do not renderFrame do not schedule another interrupt! We are done now.\e[0m"
    fi
  }
  trap handleUSR1 USR1
  handleUSR1

  while [ "$d" != "q" ] && $powerButton; do
    read  -n 1 d
    case $d in
      (j) ((ux=ux+1)) ;;
      (l) ((ux=ux-1)) ;;
      (I) ((uy=uy+1)) ;;
      (K) ((uy=uy-1)) ;;
      (k) ((uz=uz+1)) ;;
      (i) ((uz=uz-1)) ;;
      (f) ((ur=ur+1)) ;;
      (d) ((ur=ur-1)) ;;
      (q) powerButton=false ;;
    esac
  done

  ##waiting for file:frame50 to appear in main_frame50 so sleeping .05

  waitThenDelete frame$frame "End of main" .55
  #>&2 printf "\n\e[31m--${frame}main\e[0m"
  printf "\e[?25h\nDone." # Enable cursor
  #printf '%.2s\n' {1..47}
}

time main -50 # Run indefinitely or until ^C
