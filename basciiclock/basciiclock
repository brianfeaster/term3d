#!/bin/bash

##
## Poor man's console 3d lib
##

# Concepts:
#
#  * Vectors and matrices are just bash arrays and passed by value as individual args or quoted args.
#  * Everything's fixed point because bash math has no floating math support.
#  * Unit circle radius=120
#  * Radian SINTABLE 120 in size
#  * Presume +Z extends beyond screen away from viewer.
#
# Notes:
#
#  Although you can pass an array as a symbolic reference to a function as 'ary[@]' then
#  copy it locally with myary=(${!1}), it's faster just to pass the array around
#  as an expanded list of values "${ary[*]}" and copied locally with myary=($1) or just
#  used directly and consumed along with shift which seems to be the fastest.

CSI=$'\e['

SINTABLE=(0 6 12 18 25 31 37 43 49 54 60 65 70 75 80 85 89 93 97 101 104 107 110 112 114 116 117 119 119 120 120 120 119 119 117 116 114 112 110 107 104 101 97 93 89 85 80 75 70 65 60 54 49 43 37 31 25 18 12 6 0 -6 -12 -18 -25 -31 -37 -43 -49 -54 -60 -65 -70 -75 -80 -85 -89 -93 -97 -101 -104 -107 -110 -112 -114 -116 -117 -119 -119 -120 -120 -120 -119 -119 -117 -116 -114 -112 -110 -107 -104 -101 -97 -93 -89 -85 -80 -75 -70 -65 -60 -54 -49 -43 -37 -31 -25 -18 -12 -6)
COSTABLE=(120 120 119 119 117 116 114 112 110 107 104 101 97 93 89 85 80 75 70 65 60 54 49 43 37 31 25 18 12 6 0 -6 -12 -18 -25 -31 -37 -43 -49 -54 -60 -65 -70 -75 -80 -85 -89 -93 -97 -101 -104 -107 -110 -112 -114 -116 -117 -119 -119 -120 -120 -120 -119 -119 -117 -116 -114 -112 -110 -107 -104 -101 -97 -93 -89 -85 -80 -75 -70 -65 -60 -54 -49 -43 -37 -31 -25 -18 -12 -6 0 6 12 18 25 31 37 43 49 54 60 65 70 75 80 85 89 93 97 101 104 107 110 112 114 116 117 119 119 120)

function hex { printf "%02x" $1; }
function aoctopus { printf "\xf0\x9f\x90\x${1:-$(hex $((128+RANDOM%64)))}"; }

P    (){ printf %s $@ ; }
dv   (){ while [ 0 -lt $# ]; do printf '[%6d %6d %6d %6d]\n' $1 $2 $3 $4; shift 4; done; }
dvn  (){ while [ 0 -lt $# ]; do printf '[%6d %6d %6d %6d | %6d]\n' $(($1/$4)) $(($2/$4)) $(($3/$4)) $(($4/$4)) $4; shift 4; done; }
dm4  (){ printf '[%6d %6d %6d %6d]\n' $1 $2 $3 $4 $5 $6 $7 $8 $9 ${10} ${11} ${12} ${13} ${14} ${15} ${16}; }
dm4n (){ printf '[%6d %6d %6d %6d]\n' $(($1/$16)) $(($2/$16)) $(($3/$16)) $(($4/$16)) $(($5/$16)) $(($6/$16)) $(($7/$16)) $(($8/$16)) $(($9/$16)) $(($10/$16)) $(($11/$16)) $(($12/$16)) $(($13/$16)) $(($14/$16)) $(($15/$16)) $(($16/$16)); }
G2   (){ printf "\x1b[$(($1+THEIGHT2));$(($2+TWIDTH2))H$3"; }
COLORS=('0' '0;31' '0;32' '0;33' '0;34' '0;35' '0;36' '0;37' '1;30' '1;31' '1;32' '1;33' '1;34' '1;35' '1;36' '1;37')
function PC { local c=$1; shift; printf "\e[${COLORS[c]}m$*"; }


#
# Keep track of terminal dimensions.
#
TWIDTH=80
TWIDTH2=40
THEIGHT=25
THEIGHT2=13
function probeTerminal {
  read THEIGHT TWIDTH <<<$(stty size);
  THEIGHT2=$((THEIGHT/2))
  TWIDTH2=$((TWIDTH/2))
}


function inscreen { # x y
  local x=$(($1+TWIDTH2))
  local y=$(($2+THEIGHT2))
  if [ $x -lt 1 ] || [ $y -lt 1 ] || [ $TWIDTH -lt $x ] || [ $THEIGHT -lt $y ]; then
    return 1
  fi
  return 0
}


function line {
  #echo "line: $*"
  local x y m n d dx dy w ws nx ny yyxx e i
  # Make sure line is drawn from left -x to right +x in the temrinal.
  if [ $2 -le $4 ]; then
    x=$2; y=$1; m=$4; n=$3
  else
    x=$4; y=$3; m=$2; n=$1
  fi
  # (x,y) to (m,n) will always go left to right
  dx=$((m-x))
  if [ $1 -lt $3 ]; then dy=$(($3-$1)); else dy=$(($1-$3)); fi

  # Always walk or walk-step

  if [ $dy -lt $dx ]; then # Small slope so walk left and step up or down
    w=''; xwi=1;  ywi=0
    if [ $y -lt $n ]; then # walk right and down
       ws=$'\v'; xwsi=1; ywsi=1
    else                   # walk right and up
       ws=$'\eM'; xwsi=1; ywsi=-1
    fi
    nx=$dx
    ny=$dy
  else # Large slope, so walk up or down and step right
    if [ $y -lt $n ]; then # walk down and right
       w=$'\b\v'; xwi=0; ywi=1
       ws=$'\v'; xwsi=1; ywsi=1
    else                   # walk up and right
       w=$'\b\eM'; xwi=0; ywi=-1
       ws=$'\eM'; xwsi=1; ywsi=-1
    fi
    nx=$dy
    ny=$dx
  fi

  # Valid state when drawing lines on the terminal
  #  0 = out
  #  1 = in
  local state=0
  #echo [nowstartout]

  yy=$((ny + ny))
  yyxx=$((yy - nx - nx))
  e=$((yy - nx))
  i=$nx

  while [ 0 -lt $i ]; do
    if [ 0 -le $e ]; then
      if [ $state == 1 ]; then
        inscreen $x $y || { # done if out of screen
           return 0
        }
        printf "$ws$5"
      else # state == 0
        if inscreen $x $y; then
          G2 $y $x $5
          state=1
        fi
      fi
      x=$((x+xwsi)); y=$((y+ywsi))
      e=$((e + yyxx))
    else
      if [ $state == 1 ]; then
        inscreen $x $y || { # done if out of screen
          return 0
        }
        printf $w$5
      else # state == 0
        if inscreen $x $y
          then G2 $y $x $5
          state=1
        fi
      fi
      x=$((x+xwi)); y=$((y+ywi))
      e=$((e + yy))
    fi
    i=$((i-1))
  done
}



#
# Deal with time
#
# Scan hour, min, sec.  10# forces base 10 parsing of numbers beginning with 0
function probetime {
  hour=$((10#$1 * 10)); min=$((10#$2 * 2)); sec=$((10#$3 * 2))
}
probetime $(date +'%H %M %S')



#
# Create transformation matrices
#
identity="1 0 0 0  0 1 0 0   0 0 1 0  0 0 0 1"
function matRotz () { echo ${COSTABLE[$1%120]} $((- SINTABLE[$1%120])) 0 0 ${SINTABLE[$1%120]} ${COSTABLE[$1%120]} 0 0 0 0 120 0 0 0 0 120; }
function matRoty () { echo ${COSTABLE[$1%120]} 0 $((- SINTABLE[$1%120])) 0 0 120 0 0 ${SINTABLE[$1%120]} 0 ${COSTABLE[$1%120]} 0 0 0 0 120; }
function matRotx () { echo 120 0 0 0 0 ${COSTABLE[$1%120]} ${SINTABLE[$1%120]} 0 0   $((- SINTABLE[$1%120])) ${COSTABLE[$1%120]} 0 0 0 0 120; }
function matScale () { echo $1 0 0 0  0 $2 0 0  0 0 $3 0  0 0 0 1; }
function matTrans () { echo 1 0 0 $1  0 1 0 $2  0 0 1 $3  0 0 0 1; }
function matPerspective () { echo 1000 0 0 0  0 1000 0 0  0 0 1000 0  0 0 $((1000/$1)) 1000; }

#
# Multiply 4x4 row vector (first arg) with 4xN column vector (remaining args).
#  Arg1 = 'a b c d  e f g h  i j k l  m n o p'
#  Arg* = x0 y0 z0 1  x1 y1 z1 1  ...
#
function matMult () {
  local a=$1 b=$2 c=$3 d=$4 e=$5 f=$6 g=$7 h=$8 i=$9 j=${10} k=${11} l=${12} m=${13} n=${14} o=${15} p=${16}
  shift 12
  while [ 8 -le $# ] && shift 4; do
    echo $((a*$1+b*$2+c*$3+d*$4)) $((e*$1+f*$2+g*$3+h*$4)) $((i*$1+j*$2+k*$3+l*$4)) $((m*$1+n*$2+o*$3+p*$4))
  done
}


#
# Multiply N 4x4 row vectors passed as non-grouped values
#  Args: a b c d  e f g h  i j k l  m n o p ...
#
function matMultXform () {
 local aa bb cc dd ee ff gg hh ii jj kk ll mm nn oo pp
 local a=$1 b=$2 c=$3 d=$4 e=$5 f=$6 g=$7 h=$8 i=$9 j=${10} k=${11} l=${12} m=${13} n=${14} o=${15} p=${16}
 shift 16
 while :; do
   aa=$((a*$1 + b*$5 + c*$9    + d*${13}))
    bb=$((a*$2 + b*$6 + c*${10} + d*${14}))
     cc=$((a*$3 + b*$7 + c*${11} + d*${15}))
      dd=$((a*$4 + b*$8 + c*${12} + d*${16}))
   ee=$((e*$1 + f*$5 + g*$9    + h*${13}))
    ff=$((e*$2 + f*$6 + g*${10} + h*${14}))
     gg=$((e*$3 + f*$7 + g*${11} + h*${15}))
      hh=$((e*$4 + f*$8 + g*${12} + h*${16}))
   ii=$((i*$1 + j*$5 + k*$9    + l*${13}))
    jj=$((i*$2 + j*$6 + k*${10} + l*${14}))
     kk=$((i*$3 + j*$7 + k*${11} + l*${15}))
      ll=$((i*$4 + j*$8 + k*${12} + l*${16}))
   mm=$((m*$1 + n*$5 + o*$9    + p*${13}))
    nn=$((m*$2 + n*$6 + o*${10} + p*${14}))
     oo=$((m*$3 + n*$7 + o*${11} + p*${15}))
      pp=$((m*$4 + n*$8 + o*${12} + p*${16}))
   if [ 16 -eq $# ]; then echo $aa $bb $cc $dd $ee $ff $gg $hh $ii $jj $kk $ll $mm $nn $oo $pp; return; fi
   shift 16
   a=$((aa*$1 + bb*$5 + cc*$9    + dd*${13}))
    b=$((aa*$2 + bb*$6 + cc*${10} + dd*${14}))
     c=$((aa*$3 + bb*$7 + cc*${11} + dd*${15}))
      d=$((aa*$4 + bb*$8 + cc*${12} + dd*${16}))
   e=$((ee*$1 + ff*$5 + gg*$9    + hh*${13}))
    f=$((ee*$2 + ff*$6 + gg*${10} + hh*${14}))
     g=$((ee*$3 + ff*$7 + gg*${11} + hh*${15}))
      h=$((ee*$4 + ff*$8 + gg*${12} + hh*${16}))
   i=$((ii*$1 + jj*$5 + kk*$9    + ll*${13}))
    j=$((ii*$2 + jj*$6 + kk*${10} + ll*${14}))
     k=$((ii*$3 + jj*$7 + kk*${11} + ll*${15}))
      l=$((ii*$4 + jj*$8 + kk*${12} + ll*${16}))
   m=$((mm*$1 + nn*$5 + oo*$9    + pp*${13}))
    n=$((mm*$2 + nn*$6 + oo*${10} + pp*${14}))
     o=$((mm*$3 + nn*$7 + oo*${11} + pp*${15}))
      p=$((mm*$4 + nn*$8 + oo*${12} + pp*${16}))
   if [ 16 -eq $# ]; then echo $a $b $c $d $e $f $g $h $i $j $k $l $m $n $o $p; return; fi
   shift 16
 done
}


#
# Given args: x y z 1  a b c 1  aa bb cc 1
# Which define two vectors starting at x y z,
# Return true if the normal is facing viewer
#
function isFacing () {
  local zx=$(($1/$4)) zy=$(($2/$4))
  [ $((($5/$8-zx)*(${10}/${12}-zy) - ($6/$8-zy)*($9/${12}-zx))) -lt 0 ]
}


function plotLines () {
  local ch=$1; shift  ## character to plot
  while [ 0 -lt $# ]; do
    # Normalize
    x=$(($1/$4))
    y=$(($2/$4))
    z=$(($3/$4))

    x1=$(($5/$8))
    y1=$(($6/$8))
    z1=$(($7/$8))

    [ 0 -lt $z ] && [ 0 -lt $z1 ] && {
      line  $y $x $y1 $x1 "$ch"
    }
    shift 8
  done
}

function plotPoly () {
  local x y z sx sy sz lx ly lz
  local ch=$1; shift  ## character to plot

   #Start point
   x=$(($1/$4))
   y=$(($2/$4))
   #z=$(($3/$4))

   sx=$x
   sy=$y # remember this as last point
   #sz=$z

   lx=$x
   ly=$y # last coordinate
   #lz=$z

  while [ 8 -le $# ] && shift 4; do
    x=$(($1/$4))
    y=$(($2/$4)) # next point
    z=$(($3/$4))

    #[ 0 -lt $lz ] && [ 0 -lt $z ] && {
      line  $ly $lx $y $x "$ch"
    #}
    lx=$x
    ly=$y # last point
    #lz=$z

  done
  #[ 0 -lt $sz ] && [ 0 -lt $lz ] && {
    line $ly $lx $sy $sx "$ch"
  #}
}

function plotPoints () {
  local x y z ch i=0 ary="NOMINUM"
  ch=$1; shift # character to plot
  while [ 0 -lt $# ]; do
     # Normalize
     x=$(($1/$4))
     y=$(($2/$4))
     z=$(($3/$4))
     if [ 0 -lt $z ]; then
       G2 $y $x ${ary:i:1}
       i=$((i+1))
       [ $i -lt ${#ary} ] || i=0
     fi
    shift 4
  done
}

function resetAnimals {
  animal1=$(aoctopus)
  animal2=$(aoctopus)
  animal3=$(aoctopus)
}
resetAnimals


# Object descriptor and vertex stores
glables=()
gpoints=()

r=15

# Keep track of sets of points
function makePoints {
  local len=${#gpoints[*]}
  glabels=("${glabels[@]}" "$1 $2 $3 $4 $len $((len+$#-4))")
  shift 4
  gpoints=(${gpoints[@]} $*)
}

# These three non-displayed points define two vectors that
# are used to compute the "is facing us" normal vector.
normalBasis="-$r $r 0 1  $r $r 0 1  -$r -$r 0 1 "


# Transformation matrices that orient a face to either of the 6 cube faces.
matrixCubeFacea=$(matMultXform $(matRoty 0)  $(matTrans 0 0 -$r))
matrixCubeFaceb=$(matMultXform $(matRoty 30) $(matTrans 0 0 -$r))
matrixCubeFacec=$(matMultXform $(matRoty 60) $(matTrans 0 0 -$r))
matrixCubeFaced=$(matMultXform $(matRoty 90) $(matTrans 0 0 -$r))
matrixCubeFacee=$(matMultXform $(matRotx 30) $(matTrans 0 0 -$r))
matrixCubeFacef=$(matMultXform $(matRotx 90) $(matTrans 0 0 -$r))

box="$normalBasis   $r -$r 0 1    -$r -$r 0 1    -$r $r 0 1    $r $r 0 1 "

boxa=$(matMult $matrixCubeFacea $box)
boxb=$(matMult $matrixCubeFaceb $box)
boxc=$(matMult $matrixCubeFacec $box)
boxd=$(matMult $matrixCubeFaced $box)
boxe=$(matMult $matrixCubeFacee $box)
boxf=$(matMult $matrixCubeFacef $box)



function buildClockCube {
  function makeHand { echo 0 $((-$1*r/10)) 0 1  0 $((-$2*r/10)) 0 1; }
  twelve=$(echo  $normalBasis; makeHand 2 8)
  myclock=$(echo $normalBasis; for s in 10 20 30 40 50 60 70 80 90 100 110; do matMult $(matRotz s) $(makeHand 2 7); done )
  mymin=$(echo   $normalBasis; matMult $(matRotz              $min) $(makeHand 0 7))
  myhour=$(echo  $normalBasis; matMult $(matRotz  $((hour+min/12))) $(makeHand 2 4))
  mysec=$(echo   $normalBasis; matMult $(matRotz              $sec) $(makeHand 6 7))

  makePoints A        \# 9 y $boxa
  makePoints clock    \. 8 l  $(matMult      $matrixCubeFacea $myclock)
  makePoints twelve   \. 15 l $(matMult      $matrixCubeFacea $twelve)
  makePoints handmin  $animal1 6 l $(matMult $matrixCubeFacea $mymin)
  makePoints handhour $animal2 2 l $(matMult $matrixCubeFacea $myhour)
  makePoints handsec  $animal3 5 l $(matMult $matrixCubeFacea $mysec)

  makePoints B        \# 10 y $boxb
  makePoints clock    \. 8  l $(matMult       $matrixCubeFaceb $myclock)
  makePoints twelve   \. 15 l $(matMult       $matrixCubeFaceb $twelve)
  makePoints handmin  $animal1 6  l $(matMult $matrixCubeFaceb $mymin)
  makePoints handhour $animal2 2  l $(matMult $matrixCubeFaceb $myhour)
  makePoints handsec  $animal3 5  l $(matMult $matrixCubeFaceb $mysec)

  makePoints C        \# 12 y $boxc
  makePoints clock    \. 8  l $(matMult       $matrixCubeFacec $myclock)
  makePoints twelve   \. 15 l $(matMult       $matrixCubeFacec $twelve)
  makePoints handmin  $animal1 6  l $(matMult $matrixCubeFacec $mymin)
  makePoints handhour $animal2 2  l $(matMult $matrixCubeFacec $myhour)
  makePoints handsec  $animal3 5  l $(matMult $matrixCubeFacec $mysec)

  makePoints D        \# 14 y $boxd
  makePoints clock    \. 8  l $(matMult       $matrixCubeFaced $myclock)
  makePoints twelve   \. 15 l $(matMult       $matrixCubeFaced $twelve)
  makePoints handmin  $animal1 6  l $(matMult $matrixCubeFaced $mymin)
  makePoints handhour $animal2 2  l $(matMult $matrixCubeFaced $myhour)
  makePoints handsec  $animal3 5  l $(matMult $matrixCubeFaced $mysec)

  makePoints E        \# 11 y $boxe
  makePoints clock    \. 8  l $(matMult       $matrixCubeFacee $myclock)
  makePoints twelve   \. 15 l $(matMult       $matrixCubeFacee $twelve)
  makePoints handmin  $animal1 6  l $(matMult $matrixCubeFacee $mymin)
  makePoints handhour $animal2 2  l $(matMult $matrixCubeFacee $myhour)
  makePoints handsec  $animal3 5  l $(matMult $matrixCubeFacee $mysec)

  makePoints F        \# 13 y $boxf
  makePoints clock    \. 8  l $(matMult       $matrixCubeFacef $myclock)
  makePoints twelve   \. 15 l $(matMult       $matrixCubeFacef $twelve)
  makePoints handmin  $animal1 6  l $(matMult $matrixCubeFacef $mymin)
  makePoints handhour $animal2 2  l $(matMult $matrixCubeFacef $myhour)
  makePoints handsec  $animal3 5  l $(matMult $matrixCubeFacef $mysec)
}



function buildTexturedCube {
  function buildTexturedFace {
    echo $normalBasis
    d=6
    y=$((-r/d))
    while [ $y -le $((r/d)) ]; do
      x=$((-r/d))
      while [ $x -le $((r/d)) ]; do
        echo -n "$((d*x)) $((d*y)) 0 1 "
        x=$((x+1))
      done
      y=$((y+1))
    done
  }
  makePoints A a 4 p $(matMult $(matMultXform $(matTrans $1 $2 $3) $matrixCubeFacea) $(buildTexturedFace))
  makePoints B b 5 p $(matMult $(matMultXform $(matTrans $1 $2 $3) $matrixCubeFaceb) $(buildTexturedFace))
  makePoints C c 6 p $(matMult $(matMultXform $(matTrans $1 $2 $3) $matrixCubeFacec) $(buildTexturedFace))
  makePoints D d 7 p $(matMult $(matMultXform $(matTrans $1 $2 $3) $matrixCubeFaced) $(buildTexturedFace))
  makePoints E e 3 p $(matMult $(matMultXform $(matTrans $1 $2 $3) $matrixCubeFacee) $(buildTexturedFace))
  makePoints F f 2 p $(matMult $(matMultXform $(matTrans $1 $2 $3) $matrixCubeFacef) $(buildTexturedFace))
}



#
# Globals
#
powerButton=true
frame=0 # Final plotting scale
startTime=$(($(date +%s)-1))
matrixPerspective=$(matMultXform $(matPerspective 40) $(matTrans 0 0 90) $(matScale 2 2 2))



function renderObjects {
  [ $sec == 0 ] || [ "$1" == -resetAnimals ] && resetAnimals # Animal glyphs reset every minute or screen resize.
  local fileIndex=0
  local mat=$(matMultXform $matrixPerspective $(matRotx $frame) $(matTrans 0 1 0) $(matRoty $frame))
  for l in "${glabels[@]}"; do
    read n c k t a b <<<$l
    if isFacing $(matMult $mat ${gpoints[*]:$a:12}); then
      fileIndex=$((fileIndex+1))
      {
        PC $k
        case $t in 
         (y) plotPoly   "$c" $(matMult $mat ${gpoints[*]:$a+12:$b-$a-12})  ;;
         (l) plotLines  "$c" $(matMult $mat ${gpoints[*]:$a+12:$b-$a-12})  ;;
         (p) plotPoints "$c" $(matMult $mat ${gpoints[*]:$a+12:$b-$a-12})  ;;
        esac
      } >$fileIndex &
    fi
  done
  wait # for all the rendering child processes to finish

  frame=$((frame+1))
  frameRate=$((100*frame/($(date +%s)-startTime)))

  P $CSI 2J
  if [ $fileIndex != 0 ]; then
    cat $(eval "echo {1..$fileIndex}")
    rm  $(eval "echo {1..$fileIndex}")
  fi 
  PC 8 "${CSI}Hframe:$frame\nfps:$((frameRate/100)).$((frameRate%100))\nobjs:$fileIndex"
}

#
# USAGE:  basciiclock [a|b] {frame count}
#
function main {
  function main_sigint { powerButton=false; }
  function main_sigwinch { probeTerminal; renderObjects -resetAnimals; }
  framestop=${2:--1}
  P $CSI?25l # Disable cursor
  probeTerminal
  resetAnimals
  trap main_sigint   SIGINT
  trap main_sigwinch SIGWINCH
  case $1 in (a)
    while $powerButton; do
      if [ "$jiffy" != $(date +%s) ]; then
        jiffy=$(date +%s)
        #probetime $(date -r $frame +'%H %M %S')
        renderObjects
      fi
      sleep .9
    done
  ;; (b)
      #buildTexturedCube -30   0 0
      #buildTexturedCube  30   0 0
      #buildTexturedCube   0 0 -30
      buildTexturedCube   0 0  30
    while $powerButton && [ $frame != $framestop ] ; do
      probetime $(date +'%H %M %S')
      # Recompute models.  They might be time dependent like a real-time analog clock.
      glabels=()
      gpoints=()
      buildClockCube
      renderObjects
    done
  ;; esac
}

#time main b 20 # Time run 60 frames
main b # Run indefinitely or until ^C
