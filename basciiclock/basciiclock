#!/bin/bash

#### Poor man's console 3d lib
## _Concepts_
## _Testing_
## _Planes_
## _Matrices_

#### _Concepts_
##
##  * Vectors and matrices are arrays and passed by value as individual args, a
##    quoted expanded list, or referenced directly by the callee due to
##    function's dynamic scoping.
##  * Everything's fixed point because bash math has no floating math support.
##  * Unit circle radius=120
##  * Radian SINTABLE 120 in size
##  * Presume +Z extends beyond screen away from viewer.
##
## Arrays vs function arguments:
##
##  Although you can pass an array as a symbolic reference to a function as 'ary[@]'
##  then copy it locally with myary=(${!1}), it's faster just to pass the array around
##  as an expanded list of values "${ary[*]}" and copied locally with myary=($1) or
##  just used directly and consumed along with shift which seems to be the fastest.
##  Relying on dynamic scoping is event faster.
##
##  Implementing matrix multiply with a dynamic scopped target matrix isn't any
##  faster than passing all the elements as args and returning the matrix symbolically.
##
## Depth-buffer
##
##  Up until now the z coordinate has been ignored as a form of 2d projection.  Now it
##  needs to be considered when determining depth for inclusion into the the z-buffer
##  array.  The line drawing algorithm will just compute the z coordinate given either
##  the x (slope between -1 and 1) or y (slope beyond -1 or 1).  There may be a DDA
##  method that will be faster but for now this should suffice.
##
## Frame-Buffer
##
##  The terminal can't be written to directly now.  Instead 3d coordinates and
##  character the character/color will will be generated for all visible 'points'
##  then all used to populate the depth buffer.
##
## Model Store
##
##  Replace below with something that registers points (which may move) and faces that can be drawn from said points
##  The first three points of the face defines two vectors for normal computation
##    points: a b c d  e f g h ...
##    faces:  0 1 2 3  4 5 6 7  1 0 4 5  1 2 5 6 ...
##    norm:   0 1 3    4 5 7    1 0 5
##
##  Each vertex and model will be stored in global lists.  Another mechanism will be
##  used to apply copying transformations to the vertices in the global list.  The
##  renderer shouldn't care.
##
## Normal Lists
##
##  Objects that share a facing normal will share a common normal to be transformed
##  and calculated en masse prior to scheduling the rest of the rendering.
##
## Object transform List
##
##  Transformation matrix applied to one or more facing and object groups.  The global
##  matrix needs to be applied first before using so there needs to be a pre and
##  post transformed list.
##
####


#### _Testing_
##
function assertEquals {
  IFS=''
  local title="$1" res="$2" exp="$3"
  #echo -e "\e[32m$1\n\e[0;31m$2\e[0m"
  if [ "$res" != "$exp" ]; then
    echo -e "\e[31;1m[FAIL] $title\e[0;33m"
    diff <(echo $res) <(echo $exp)
    echo -e "\e[0m"
    exit $?
  fi
  unset IFS
}
#### _Testing_



##
## Math stuff.  Mappings from [0..120] -> [-120..120]
##
SINTABLE=(0 6 12 18 25 31 37 43 49 54 60 65 70 75 80 85 89 93 97 101 104 107 110 112 114 116 117 119 119 120 120 120 119 119 117 116 114 112 110 107 104 101 97 93 89 85 80 75 70 65 60 54 49 43 37 31 25 18 12 6 0 -6 -12 -18 -25 -31 -37 -43 -49 -54 -60 -65 -70 -75 -80 -85 -89 -93 -97 -101 -104 -107 -110 -112 -114 -116 -117 -119 -119 -120 -120 -120 -119 -119 -117 -116 -114 -112 -110 -107 -104 -101 -97 -93 -89 -85 -80 -75 -70 -65 -60 -54 -49 -43 -37 -31 -25 -18 -12 -6)
SINTABLEI=(0 -6 -12 -18 -25 -31 -37 -43 -49 -54 -60 -65 -70 -75 -80 -85 -89 -93 -97 -101 -104 -107 -110 -112 -114 -116 -117 -119 -119 -120 -120 -120 -119 -119 -117 -116 -114 -112 -110 -107 -104 -101 -97 -93 -89 -85 -80 -75 -70 -65 -60 -54 -49 -43 -37 -31 -25 -18 -12 -6 0 6 12 18 25 31 37 43 49 54 60 65 70 75 80 85 89 93 97 101 104 107 110 112 114 116 117 119 119 120 120 120 119 119 117 116 114 112 110 107 104 101 97 93 89 85 80 75 70 65 60 54 49 43 37 31 25 18 12 6)
COSTABLE=(120 120 119 119 117 116 114 112 110 107 104 101 97 93 89 85 80 75 70 65 60 54 49 43 37 31 25 18 12 6 0 -6 -12 -18 -25 -31 -37 -43 -49 -54 -60 -65 -70 -75 -80 -85 -89 -93 -97 -101 -104 -107 -110 -112 -114 -116 -117 -119 -119 -120 -120 -120 -119 -119 -117 -116 -114 -112 -110 -107 -104 -101 -97 -93 -89 -85 -80 -75 -70 -65 -60 -54 -49 -43 -37 -31 -25 -18 -12 -6 0 6 12 18 25 31 37 43 49 54 60 65 70 75 80 85 89 93 97 101 104 107 110 112 114 116 117 119 119 120)
COSTABLEI=(-120 -120 -119 -119 -117 -116 -114 -112 -110 -107 -104 -101 -97 -93 -89 -85 -80 -75 -70 -65 -60 -54 -49 -43 -37 -31 -25 -18 -12 -6 0 6 12 18 25 31 37 43 49 54 60 65 70 75 80 85 89 93 97 101 104 107 110 112 114 116 117 119 119 120 120 120 119 119 117 116 114 112 110 107 104 101 97 93 89 85 80 75 70 65 60 54 49 43 37 31 25 18 12 6 0 -6 -12 -18 -25 -31 -37 -43 -49 -54 -60 -65 -70 -75 -80 -85 -89 -93 -97 -101 -104 -107 -110 -112 -114 -116 -117 -119 -119 -120)

function range { eval echo {$1..$2}; }
function prerange { eval echo $1{$2..$3}; }


##
## Time stuff
##
## Consider time as normalized values:  hours [0..240] minuts & seconds [0..120].
## I do this because the above trig function domains are [0..120].
##
hour=0
min=0
sec=0
function timeProbe {
  local h m s
  if [ $# == 1 ]; then
    read h m s <<< $(date -r $1 +'%H %M %S')
  else
    read h m s  <<< $(date +'%H %M %S')
  fi
  hour=$((10#$h * 10)) #10# forces base 10 values otherwise octal 09 can't be parsed.
  min=$((10#$m * 2))
  sec=$((10#$s * 2))
}
timeProbe $(date +'%H %M %S')



##
## Terminal stuff
##
TWIDTH=80
TWIDTH2=40
THEIGHT=25
THEIGHT2=13
function hex { printf "%02x" $1; }
# UTF-8 critter glyphs
function acritter { printf "\xf0\x9f\x90\x${1:-$(hex $((128+RANDOM%64)))}"; }
function resetCritters {
  animal1=$(acritter)
  animal2=$(acritter)
  animal3=$(acritter)
}
resetCritters

function terminalProbe {
  read THEIGHT TWIDTH <<<$(stty size)
  THEIGHT2=$((THEIGHT/2))
  TWIDTH2=$((TWIDTH/2))
}

function terminalIsInScreen { # ARGS: x y
  local x=$(($1+TWIDTH2))
  local y=$(($2+THEIGHT2))
  if [ $x -lt 0 ] || [ $y -lt 0 ] || [ $TWIDTH -le $x ] || [ $THEIGHT -le $y ]; then
    return 1
  fi
  return 0
}

function G2 { printf "\e[$(($1+THEIGHT2));$(($2+TWIDTH2))H$3"; }

function terminalDrawLine {
  local x y m n d dx dy w ws nx ny yyxx e i
  local z=$5
  local kl=$6
  local ch=$7
  # Make sure line is drawn from left -x to right +x in the temrinal.
  if [ $2 -le $4 ]; then
    x=$2; y=$1; m=$4; n=$3
  else
    x=$4; y=$3; m=$2; n=$1
  fi
  # (x,y) to (m,n) will always go left to right
  dx=$((m-x))
  if [ $1 -lt $3 ]; then dy=$(($3-$1)); else dy=$(($1-$3)); fi

  # Always walk or walk-step

  if [ $dy -lt $dx ]; then # Small slope so walk left and step up or down
    w=''; xwi=1;  ywi=0
    if [ $y -lt $n ]; then # walk right and down
       ws=$'\v'; xwsi=1; ywsi=1
    else                   # walk right and up
       ws=$'\eM'; xwsi=1; ywsi=-1
    fi
    nx=$dx
    ny=$dy
  else # Large slope, so walk up or down and step right
    if [ $y -lt $n ]; then # walk down and right
       w=$'\b\v'; xwi=0; ywi=1
       ws=$'\v'; xwsi=1; ywsi=1
    else                   # walk up and right
       w=$'\b\eM'; xwi=0; ywi=-1
       ws=$'\eM'; xwsi=1; ywsi=-1
    fi
    nx=$dy
    ny=$dx
  fi

  # Valid state when drawing lines on the terminal
  #  0 = out
  #  1 = in
  local state=0

  yy=$((ny + ny))
  yyxx=$((yy - nx - nx))
  e=$((yy - nx))
  i=$nx

  while [ 0 -lt $i ]; do
    if [ 0 -le $e ]; then # above mid-point
      if [ $state == 1 ]; then
        if terminalIsInScreen $x $y; then # done if out of screen
          echo $((x+TWIDTH2)) $((y+THEIGHT2)) $z $kl $ch
        else
           return 0
        fi
      else # state == 0
        if terminalIsInScreen $x $y; then
          state=1
          echo $((x+TWIDTH2)) $((y+THEIGHT2)) $z $kl $ch
        fi
      fi
      x=$((x+xwsi)); y=$((y+ywsi))
      e=$((e + yyxx))
    else # below mid-point
      if [ $state == 1 ]; then
        if terminalIsInScreen $x $y; then  # done if out of screen
          echo $((x+TWIDTH2)) $((y+THEIGHT2)) $z $kl $ch
        else
          return 0
        fi
      else # state == 0
        if terminalIsInScreen $x $y; then
          state=1
          echo $((x+TWIDTH2)) $((y+THEIGHT2)) $z $kl $ch
        fi
      fi
      x=$((x+xwi)); y=$((y+ywi))
      e=$((e + yy))
    fi
    i=$((i-1))
  done
}


function terminalDrawLineDirect {
  local x y m n d dx dy w ws nx ny yyxx e i
  # Make sure line is drawn from left -x to right +x in the temrinal.
  if [ $2 -le $4 ]; then
    x=$2; y=$1; m=$4; n=$3
  else
    x=$4; y=$3; m=$2; n=$1
  fi
  # (x,y) to (m,n) will always go left to right
  dx=$((m-x))
  if [ $1 -lt $3 ]; then dy=$(($3-$1)); else dy=$(($1-$3)); fi

  # Always walk or walk-step

  if [ $dy -lt $dx ]; then # Small slope so walk left and step up or down
    w=''; xwi=1;  ywi=0
    if [ $y -lt $n ]; then # walk right and down
       ws=$'\v'; xwsi=1; ywsi=1
    else                   # walk right and up
       ws=$'\eM'; xwsi=1; ywsi=-1
    fi
    nx=$dx
    ny=$dy
  else # Large slope, so walk up or down and step right
    if [ $y -lt $n ]; then # walk down and right
       w=$'\b\v'; xwi=0; ywi=1
       ws=$'\v'; xwsi=1; ywsi=1
    else                   # walk up and right
       w=$'\b\eM'; xwi=0; ywi=-1
       ws=$'\eM'; xwsi=1; ywsi=-1
    fi
    nx=$dy
    ny=$dx
  fi

  # Valid state when drawing lines on the terminal
  #  0 = out
  #  1 = in
  local state=0

  yy=$((ny + ny))
  yyxx=$((yy - nx - nx))
  e=$((yy - nx))
  i=$nx

  while [ 0 -lt $i ]; do
    if [ 0 -le $e ]; then
      if [ $state == 1 ]; then
        if ! terminalIsInScreen $x $y; then # done if out of screen
           return 0
        fi
        printf "$ws$5"
      else # state == 0
        if terminalIsInScreen $x $y; then
          G2 $y $x $5
          state=1
        fi
      fi
      x=$((x+xwsi)); y=$((y+ywsi))
      e=$((e + yyxx))
    else
      if [ $state == 1 ]; then
        if !terminalIsInScreen $x $y; then # done if out of screen
          return 0
        fi
        printf $w$5
      else # state == 0
        if terminalIsInScreen $x $y
          then G2 $y $x $5
          state=1
        fi
      fi
      x=$((x+xwi)); y=$((y+ywi))
      e=$((e + yy))
    fi
    i=$((i-1))
  done
}



##
## Debugging
##
dv   (){ while [ 0 -lt $# ]; do printf '[%3d %3d %3d %3d ]\n' $1 $2 $3 $4; shift; shift; shift; shift ; done; }
dvgl (){ while [ 0 -lt $# ]; do printf "($2 $3 $4 $5 $6)\n"; shift 6; done; }
dvn  (){ while [ 0 -lt $# ]; do printf '[%6d %6d %6d %6d | %6d]\n' $(($1/$4)) $(($2/$4)) $(($3/$4)) $(($4/$4)) $4; shift 4; done; }
dm4  (){ while [ 0 -lt $# ]; do printf '[%9d %9d %9d %9d]\n' $1 $2 $3 $4 $5 $6 $7 $8 $9 ${10} ${11} ${12} ${13} ${14} ${15} ${16}; echo; shift 16; done; }
COLORS=('0' '0;31' '0;32' '0;33' '0;34' '0;35' '0;36' '0;37' '1;30' '1;31' '1;32' '1;33' '1;34' '1;35' '1;36' '1;37')
function PC { local c=$1; shift; printf "\e[${COLORS[c]}m$*"; }



##
## Vectors:  array of concatenated homogeneous 4d vectors.  (size count length)
##
vectors=()
function vectorsLength { echo $((${#vectors[*]}/4)); }
#function vectorsSetXYZN  {
#  local i=$1
#  x=${vectors[$i*4]}
#  y=${vectors[$i*4+1]}
#  z=${vectors[$i*4+2]}
#  n=${vectors[$i*4+3]}
#}
function vectorsAppend { # [x y z n ...] => &ret
  local len=${#vectors[*]}
  ret=$((len/4)) # keep track of the starting vector index
  while [ 0 -lt $# ]; do
    vectors[len+0]=$1
    vectors[len+1]=$2
    vectors[len+2]=$3
    vectors[len+3]=$4
    shift 4
    len=$((len+4))
  done
}

function vectorsDump {
  local i=0
  echo "-- $(vectorsLength) vectors ----"
  dv ${vectors[*]} | while read x; do echo $i $x; i=$((i+1)); done
}



#### _Planes_
##
## Array of indices into the vectors array pointing at groups of 4 consecutive vertices.  For normal occlusion.
##
planes=(-1 -1 -1 -1)    # Array of vector indices and matrix indices that reference three consecutive points in the vectors array defining a plane
facing=(1 0) # Result of normal calc for each plane (group of 3 normalized vertices) with two defaults (false true)
function planesLength { echo $((${#planes[*]}/2)); }
function planesAppend { # [ vectorsIdx matrixIdx ... ] => &ret
  local len=${#planes[*]}
  ret=$((len/2))
  while [ 0 -lt $# ]; do
    planes[len]=$1
    planes[len+1]=$2

    facing[len/2]=-1
    shift ; shift
    len=$((len+2))
  done
}

function planesDump {
  local i=2 v m max=$(planesLength)
  echo "-- $(planesLength) planes ----"

  echo 0: vecIdx=na matIdx=na [na] [na] [na] facing="${facing[0]}"
  echo 1: vecIdx=na matIdx=na [na] [na] [na] facing="${facing[1]}"

  while [ $i -lt $max ]; do
    v=${planes[i*2]}
    m=${planes[i*2+1]}
    echo $i: vecIdx=$v matIdx=$m $(dv ${vectors[*]:v*4:12}) facing="${facing[i]}"
    i=$((i+1))
  done
}

assertEquals Planes \
"$(vectorsAppend 0 0 0 0  1 1 1 1  2 2 2 2
   vectorsAppend 8 0 0 0  8 1 1 1  8 2 2 2
   vectorsAppend 9 0 0 0  9 1 1 1  9 2 2 2
   planesAppend 0 0  3 0  6 1
   planesDump)" \
"$(echo '-- 5 planes ----'
   echo '0: vecIdx=na matIdx=na [na] [na] [na] facing=1'
   echo '1: vecIdx=na matIdx=na [na] [na] [na] facing=0'
   echo '2: vecIdx=0 matIdx=0 [ 0 0 0 0 ] [ 1 1 1 1 ] [ 2 2 2 2 ] facing=-1'
   echo '3: vecIdx=3 matIdx=0 [ 8 0 0 0 ] [ 8 1 1 1 ] [ 8 2 2 2 ] facing=-1'
   echo '4: vecIdx=6 matIdx=1 [ 9 0 0 0 ] [ 9 1 1 1 ] [ 9 2 2 2 ] facing=-1')"

##
#### _Planes_


##
## Objects: Array of objects representing points, lines, and closed polygon
##
objects=() #( label type color char preMatIdx planeIdx vecIdxCount vecIdx... ...)

function objectsLength { : || complicated;  }

function objectsAdd { # Args: label type color char matIdx planeIdx vectorsIdx...
  local len=${#objects[*]}
  objects[len+0]=$1 # label
  objects[len+1]=$2 # type
  objects[len+2]=$3 # color
  objects[len+3]=$4 # char
  objects[len+4]=$5 # matIdx
  objects[len+5]=$6 # planeIdx
  shift 6
  objects[len+6]=$(($#)) # vector count
  len=$((len+7))
  while [ 0 -lt $# ]; do
    objects[len]=$1
    shift
    len=$((len+1))
  done
}

function objectsDump {
  echo "-- objects ----"
  local oi=0 max=${#objects[*]} count p c=0
  while [ $oi -lt $max ]; do
    printf "%d %8s %s [%d%s] m=%d " $c "\"${objects[oi+0]}\"" ${objects[oi+1]} ${objects[oi+2]} ${objects[oi+3]} ${objects[oi+4]}
    p=${objects[oi+5]}
    case $p in
      (0) printf "{F}" ;;
      (1) printf "{T}" ;;
      (*) printf "{%d}" $((p-2)) ;;
    esac
    count=${objects[oi+6]}
    printf " $count:"
    oi=$((oi+7))
    case ${objects[oi-6]} in
      (*) printf " %s" ${objects[*]:oi:count} ;;      # Dump indices representing each point
      (l) printf " %2d-%-2d" ${objects[*]:oi:count} ;; # Dump index pairs representing a line
    esac
    echo "."
    oi=$((oi + count))
    c=$((c+1))
  done
}



##
## Matrix
##

matIdent="1 0 0 0  0 1 0 0   0 0 1 0  0 0 0 1"
function matRotz () { echo ${COSTABLE[(120+$1)%120]} ${SINTABLEI[(120+$1)%120]} 0 0 ${SINTABLE[(120+$1)%120]} ${COSTABLE[(120+$1)%120]} 0 0 0 0 120 0 0 0 0 120; }
function matRoty () { echo ${COSTABLE[(120+$1)%120]} 0 ${SINTABLEI[(120+$1)%120]} 0 0 120 0 0 ${SINTABLE[(120+$1)%120]} 0 ${COSTABLE[(120+$1)%120]} 0 0 0 0 120; }
function matRotx () { echo 120 0 0 0 0 ${COSTABLE[(120+$1)%120]} ${SINTABLE[(120+$1)%120]} 0 0   ${SINTABLEI[(120+$1)%120]} ${COSTABLE[(120+$1)%120]} 0 0 0 0 120; }
function matScale () { echo $1 0 0 0  0 $2 0 0  0 0 $3 0  0 0 0 1; }
function matTrans () { echo 1 0 0 $1  0 1 0 $2  0 0 1 $3  0 0 0 1; }
function matPerspective () { echo 1000 0 0 0  0 1000 0 0  0 0 1000 0  0 0 $((1000/$1)) 1000; }

#
# Multiply 4x4 row vector arg1 with 4xN column vector (remaining args).
#  Args: a b c d e f g h i j k l m n o p   x y z n ...
#
function matMultTransNVec () {
  local a=$1 b=$2 c=$3 d=$4 e=$5 f=$6 g=$7 h=$8 i=$9 j=${10} k=${11} l=${12} m=${13} n=${14} o=${15} p=${16}
  shift 12
  while [ 8 -le $# ] && shift 4; do
    echo $((a*$1+b*$2+c*$3+d*$4)) $((e*$1+f*$2+g*$3+h*$4)) $((i*$1+j*$2+k*$3+l*$4)) $((m*$1+n*$2+o*$3+p*$4))
  done
}


#
# Multiply N 4x4 row vectors passed expanded
#  Args: a b c d e f g h i j k l m n o p ...
#
function matMultNTrans () {
 local a=$1 b=$2 c=$3 d=$4 e=$5 f=$6 g=$7 h=$8 i=$9 j=${10} k=${11} l=${12} m=${13} n=${14} o=${15} p=${16}
 local aa bb cc dd ee ff gg hh ii jj kk ll mm nn oo pp
 shift 16
 while :; do
   aa=$((a*$1 + b*$5 + c*$9    + d*${13}))
    bb=$((a*$2 + b*$6 + c*${10} + d*${14}))
     cc=$((a*$3 + b*$7 + c*${11} + d*${15}))
      dd=$((a*$4 + b*$8 + c*${12} + d*${16}))
   ee=$((e*$1 + f*$5 + g*$9    + h*${13}))
    ff=$((e*$2 + f*$6 + g*${10} + h*${14}))
     gg=$((e*$3 + f*$7 + g*${11} + h*${15}))
      hh=$((e*$4 + f*$8 + g*${12} + h*${16}))
   ii=$((i*$1 + j*$5 + k*$9    + l*${13}))
    jj=$((i*$2 + j*$6 + k*${10} + l*${14}))
     kk=$((i*$3 + j*$7 + k*${11} + l*${15}))
      ll=$((i*$4 + j*$8 + k*${12} + l*${16}))
   mm=$((m*$1 + n*$5 + o*$9    + p*${13}))
    nn=$((m*$2 + n*$6 + o*${10} + p*${14}))
     oo=$((m*$3 + n*$7 + o*${11} + p*${15}))
      pp=$((m*$4 + n*$8 + o*${12} + p*${16}))
   if [ 16 -eq $# ]; then echo $aa $bb $cc $dd $ee $ff $gg $hh $ii $jj $kk $ll $mm $nn $oo $pp; return; fi
   shift 16
   a=$((aa*$1 + bb*$5 + cc*$9    + dd*${13}))
    b=$((aa*$2 + bb*$6 + cc*${10} + dd*${14}))
     c=$((aa*$3 + bb*$7 + cc*${11} + dd*${15}))
      d=$((aa*$4 + bb*$8 + cc*${12} + dd*${16}))
   e=$((ee*$1 + ff*$5 + gg*$9    + hh*${13}))
    f=$((ee*$2 + ff*$6 + gg*${10} + hh*${14}))
     g=$((ee*$3 + ff*$7 + gg*${11} + hh*${15}))
      h=$((ee*$4 + ff*$8 + gg*${12} + hh*${16}))
   i=$((ii*$1 + jj*$5 + kk*$9    + ll*${13}))
    j=$((ii*$2 + jj*$6 + kk*${10} + ll*${14}))
     k=$((ii*$3 + jj*$7 + kk*${11} + ll*${15}))
      l=$((ii*$4 + jj*$8 + kk*${12} + ll*${16}))
   m=$((mm*$1 + nn*$5 + oo*$9    + pp*${13}))
    n=$((mm*$2 + nn*$6 + oo*${10} + pp*${14}))
     o=$((mm*$3 + nn*$7 + oo*${11} + pp*${15}))
      p=$((mm*$4 + nn*$8 + oo*${12} + pp*${16}))
   if [ 16 -eq $# ]; then echo $a $b $c $d $e $f $g $h $i $j $k $l $m $n $o $p; return; fi
   shift 16
 done
}
assertEquals matMultNTrans \
 "$(matMultNTrans 2 0 0 0  0 3 0 0  0 0 4 0  0 0 0 5 \
                 2 3 4 5  9 8 7 6  3 9 7 5  8 2 4 6 \
                 0 0 0 1  0 0 1 0  0 1 0 0  1 0 0 0)" \
 "$(echo '10 8 6 4 18 21 24 27 20 28 36 12 30 20 10 40')"
assertEquals matMultNTrans \
 "$(matMultNTrans 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17   2 3 4 5  6 7 8 9  10 11 12 13  14 15 16 17)" \
 "$(echo '132 146 160 174 260 290 320 350 388 434 480 526 516 578 640 702')"



# This isn't any faster.  Expects &mat and N matrices passed symbolically expanded.
function matMultXformLocal () { # &mat
 local a b c d
 while :; do
   a=${mat[0]}
   b=${mat[1]}
   c=${mat[2]}
   d=${mat[3]}
   mat[0]=$((a*$1 + b*$5 + c*$9    + d*${13}))
    mat[1]=$((a*$2 + b*$6 + c*${10} + d*${14}))
     mat[2]=$((a*$3 + b*$7 + c*${11} + d*${15}))
      mat[3]=$((a*$4 + b*$8 + c*${12} + d*${16}))
   a=${mat[4]}
   b=${mat[5]}
   c=${mat[6]}
   d=${mat[7]}
   mat[4]=$((a*$1 + b*$5 + c*$9    + d*${13}))
    mat[5]=$((a*$2 + b*$6 + c*${10} + d*${14}))
     mat[6]=$((a*$3 + b*$7 + c*${11} + d*${15}))
      mat[7]=$((a*$4 + b*$8 + c*${12} + d*${16}))
   a=${mat[8]}
   b=${mat[9]}
   c=${mat[10]}
   d=${mat[11]}
   mat[8]=$((a*$1 + b*$5 + c*$9    + d*${13}))
    mat[9]=$((a*$2 + b*$6 + c*${10} + d*${14}))
     mat[10]=$((a*$3 + b*$7 + c*${11} + d*${15}))
      mat[11]=$((a*$4 + b*$8 + c*${12} + d*${16}))
   a=${mat[12]}
   b=${mat[13]}
   c=${mat[14]}
   d=${mat[15]}
   mat[12]=$((a*$1 + b*$5 + c*$9    + d*${13}))
    mat[13]=$((a*$2 + b*$6 + c*${10} + d*${14}))
     mat[14]=$((a*$3 + b*$7 + c*${11} + d*${15}))
      mat[15]=$((a*$4 + b*$8 + c*${12} + d*${16}))
   [ 32 -le $# ] && return
   shift 16
 done
}


function matMultTransVecNormalized { # &mi &vx &vy &vz &vn => &x &y &z
  local n=$((mattrans[mi+12]*vx+mattrans[mi+13]*vy+mattrans[mi+14]*vz+mattrans[mi+15]*vn))
  x=$(((mattrans[mi+0]*vx+mattrans[mi+1]*vy+mattrans[mi+2]*vz+mattrans[mi+3]*vn)/n))
  y=$(((mattrans[mi+4]*vx+mattrans[mi+5]*vy+mattrans[mi+6]*vz+mattrans[mi+7]*vn)/n))
  z=$(((mattrans[mi+8]*vx+mattrans[mi+9]*vy+mattrans[mi+10]*vz+mattrans[mi+11]*vn)/n))
}


##
## _Matrices_
##
matstat=(1 0 0 0  0 1 0 0  0 0 1 0  0 0 0 1) # Static list of matrices.  First one is the global transform matrix.  Starts off as identity and is mutated.
mattrans=(1 0 0 0  0 1 0 0  0 0 1 0  0 0 0 1) # Transformed (by the global mat) matrices.  Recalculated every frame.

function matAppend { # => &ret
  local len=${#matstat[*]}
  ret=$((len/16)) # keep track of the starting vector index
  while [ 16 -le $# ]; do
    matstat[len+0]=$1;     matstat[len+1]=$2;     matstat[len+2]=$3;     matstat[len+3]=$4
    matstat[len+4]=$5;     matstat[len+5]=$6;     matstat[len+6]=$7;     matstat[len+7]=$8
    matstat[len+8]=$9;     matstat[len+9]=${10};  matstat[len+10]=${11}; matstat[len+11]=${12}
    matstat[len+12]=${13}; matstat[len+13]=${14}; matstat[len+14]=${15}; matstat[len+15]=${16}
    shift 16
    len=$((len+16))
   done
}

function matSet { # &len
  local x=$(($1*16)) # start at matrix index $1
  matstat[x+0]=$2;     matstat[x+1]=$3;     matstat[x+2]=$4;     matstat[x+3]=$5
  matstat[x+4]=$6;     matstat[x+5]=$7;     matstat[x+6]=$8;     matstat[x+7]=$9
  matstat[x+8]=${10};  matstat[x+9]=${11};  matstat[x+10]=${12}; matstat[x+11]=${13}
  matstat[x+12]=${14}; matstat[x+13]=${15}; matstat[x+14]=${16}; matstat[x+15]=${17}
}

function matSetGlobal { # &len
  local x=$(($1*16)) # start at matrix index $1
  matstat[x+0]=$2;     matstat[x+1]=$3;     matstat[x+2]=$4;     matstat[x+3]=$5
  matstat[x+4]=$6;     matstat[x+5]=$7;     matstat[x+6]=$8;     matstat[x+7]=$9
  matstat[x+8]=${10};  matstat[x+9]=${11};  matstat[x+10]=${12}; matstat[x+11]=${13}
  matstat[x+12]=${14}; matstat[x+13]=${15}; matstat[x+14]=${16}; matstat[x+15]=${17}

  mattrans[x+0]=$2;     mattrans[x+1]=$3;     mattrans[x+2]=$4;     mattrans[x+3]=$5
  mattrans[x+4]=$6;     mattrans[x+5]=$7;     mattrans[x+6]=$8;     mattrans[x+7]=$9
  mattrans[x+8]=${10};  mattrans[x+9]=${11};  mattrans[x+10]=${12}; mattrans[x+11]=${13}
  mattrans[x+12]=${14}; mattrans[x+13]=${15}; mattrans[x+14]=${16}; mattrans[x+15]=${17}
}

# Multiply every static matrix matstat[*] with the global matrix matstat[0] into the mattrans array
function matTransformStatic { # &mat &matstat $mattrans
 local a=${matstat[0]} b=${matstat[1]} c=${matstat[2]} d=${matstat[3]} e=${matstat[4]} f=${matstat[5]} g=${matstat[6]} h=${matstat[7]} i=${matstat[8]} j=${matstat[9]} k=${matstat[10]} l=${matstat[11]} m=${matstat[12]} n=${matstat[13]} o=${matstat[14]} p=${matstat[15]} aa bb cc dd ee ff gg hh ii jj kk ll mm nn oo pp
 local x=16 max=${#matstat[*]}
 while [ $x -lt $max ] ; do
   aa=${matstat[x+0]}  bb=${matstat[x+1]}  cc=${matstat[x+2]}  dd=${matstat[x+3]}
   ee=${matstat[x+4]}  ff=${matstat[x+5]}  gg=${matstat[x+6]}  hh=${matstat[x+7]}
   ii=${matstat[x+8]}  jj=${matstat[x+9]}  kk=${matstat[x+10]} ll=${matstat[x+11]}
   mm=${matstat[x+12]} nn=${matstat[x+13]} oo=${matstat[x+14]} pp=${matstat[x+15]}
   mattrans[x+0]=$((a*aa + b*ee + c*ii + d*mm))
   mattrans[x+1]=$((a*bb + b*ff + c*jj + d*nn))
   mattrans[x+2]=$((a*cc + b*gg + c*kk + d*oo))
   mattrans[x+3]=$((a*dd + b*hh + c*ll + d*pp))

   mattrans[x+4]=$((e*aa + f*ee + g*ii + h*mm))
   mattrans[x+5]=$((e*bb + f*ff + g*jj + h*nn))
   mattrans[x+6]=$((e*cc + f*gg + g*kk + h*oo))
   mattrans[x+7]=$((e*dd + f*hh + g*ll + h*pp))

   mattrans[x+8]=$(( i*aa + j*ee + k*ii + l*mm))
   mattrans[x+9]=$(( i*bb + j*ff + k*jj + l*nn))
   mattrans[x+10]=$((i*cc + j*gg + k*kk + l*oo))
   mattrans[x+11]=$((i*dd + j*hh + k*ll + l*pp))

   mattrans[x+12]=$((m*aa + n*ee + o*ii + p*mm))
   mattrans[x+13]=$((m*bb + n*ff + o*jj + p*nn))
   mattrans[x+14]=$((m*cc + n*gg + o*kk + p*oo))
   mattrans[x+15]=$((m*dd + n*hh + o*ll + p*pp))

   x=$((x+16))
 done
}

function matDump {
  local i=0 v
  local count=$((${#matstat[*]}/16))
  for i in $(range 0 $((count - 1))); do
    echo "-- matrix static $i ----"
    dm4 ${matstat[*]:i*16:16}
  done
}

function matTransDump {
  local i=0 v
  local count=$((${#mattrans[*]}/16))
  for i in $(range 0 $((count - 1))); do
    echo "-- matrix transformed $i ----"
    dm4 ${mattrans[*]:i*16:16}
  done
}

assertEquals matstat1 \
 "$(matAppend {1..16}
    dv ${matstat[*]})" \
 "$(echo '[  1   0   0   0 ]'
    echo '[  0   1   0   0 ]'
    echo '[  0   0   1   0 ]'
    echo '[  0   0   0   1 ]'
    echo '[  1   2   3   4 ]'
    echo '[  5   6   7   8 ]'
    echo '[  9  10  11  12 ]'
    echo '[ 13  14  15  16 ]')"
assertEquals matstat2 \
 "$(matSetGlobal 1 {0..15}
    dv ${matstat[*]})" \
 "$(echo '[  1   0   0   0 ]'
    echo '[  0   1   0   0 ]'
    echo '[  0   0   1   0 ]'
    echo '[  0   0   0   1 ]'
    echo '[  0   1   2   3 ]'
    echo '[  4   5   6   7 ]'
    echo '[  8   9  10  11 ]'
    echo '[ 12  13  14  15 ]')"
assertEquals matTransformStatic \
 "$(matSetGlobal 0  2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17
    matAppend 1 0 0 0  0 1 0 0  0 0 1 0  0 0 0 1
    matAppend 0 0 0 1  0 0 1 0  0 1 0 0  1 0 0 0
    matAppend 2 3 4 5  6 7 8 9  10 11 12 13  14 15 16 17
    matTransformStatic
    matTransDump)" \
 "$(echo '-- matrix transformed 0 ----'
    echo '[        2         3         4         5]'
    echo '[        6         7         8         9]'
    echo '[       10        11        12        13]'
    echo '[       14        15        16        17]'
    echo
    echo '-- matrix transformed 1 ----'
    echo '[        2         3         4         5]'
    echo '[        6         7         8         9]'
    echo '[       10        11        12        13]'
    echo '[       14        15        16        17]'
    echo
    echo '-- matrix transformed 2 ----'
    echo '[        5         4         3         2]'
    echo '[        9         8         7         6]'
    echo '[       13        12        11        10]'
    echo '[       17        16        15        14]'
    echo
    echo '-- matrix transformed 3 ----'
    echo '[      132       146       160       174]'
    echo '[      260       290       320       350]'
    echo '[      388       434       480       526]'
    echo '[      516       578       640       702]')"
##
#### _Matrices_


# Given index into vectors array (... x y z n   x' y' z' n'   x" y" z" n" ...), which define two vectors starting at x y z, and
# index into matrix transform array, the transform to apply to the normal plane,
# Return true if the normal is facing viewer
# Completely inlined matrix multiply and normal calculation with z-component optimization
function isPlaneFacing { # (idxVectors idxMatrices)
  local vi=$((4*$1)) vx vy vz vn n x0 y0 x1 y1 x2 y2
  local mi=$((16*$2))
  vx=${vectors[vi]}
  vy=${vectors[vi+1]}
  vz=${vectors[vi+2]}
  vn=${vectors[vi+3]}
  n=$((mattrans[mi+12]*vx+mattrans[mi+13]*vy+mattrans[mi+14]*vz+mattrans[mi+15]*vn))
  x0=$((4*(mattrans[mi+0]*vx+mattrans[mi+1]*vy+mattrans[mi+2]*vz+mattrans[mi+3]*vn)/n))
  y0=$((4*(mattrans[mi+4]*vx+mattrans[mi+5]*vy+mattrans[mi+6]*vz+mattrans[mi+7]*vn)/n))
  vx=${vectors[vi+4]}
  vy=${vectors[vi+5]}
  vz=${vectors[vi+6]}
  vn=${vectors[vi+7]}
  n=$((mattrans[mi+12]*vx+mattrans[mi+13]*vy+mattrans[mi+14]*vz+mattrans[mi+15]*vn))
  x1=$((4*(mattrans[mi+0]*vx+mattrans[mi+1]*vy+mattrans[mi+2]*vz+mattrans[mi+3]*vn)/n))
  y1=$((4*(mattrans[mi+4]*vx+mattrans[mi+5]*vy+mattrans[mi+6]*vz+mattrans[mi+7]*vn)/n))
  vx=${vectors[vi+8]}
  vy=${vectors[vi+9]}
  vz=${vectors[vi+10]}
  vn=${vectors[vi+11]}
  n=$((mattrans[mi+12]*vx+mattrans[mi+13]*vy+mattrans[mi+14]*vz+mattrans[mi+15]*vn))
  x2=$((4*(mattrans[mi+0]*vx+mattrans[mi+1]*vy+mattrans[mi+2]*vz+mattrans[mi+3]*vn)/n))
  y2=$((4*(mattrans[mi+4]*vx+mattrans[mi+5]*vy+mattrans[mi+6]*vz+mattrans[mi+7]*vn)/n))
  [ $(((x1-x0)*(y2-y0)-(y1-y0)*(x2-x0))) -lt 0 ]
}

function plotLines () { # &oi &cl &ch &last &mat
  local idx=$oi vi vx vy vz vn a b c x y z
  while [ $idx -lt $last ]; do # over every vector index in object
    vi=${objects[idx]}
    vx=${vectors[$vi*4]}
    vy=${vectors[$vi*4+1]}
    vz=${vectors[$vi*4+2]}
    vn=${vectors[$vi*4+3]}
    matMultTransVecNormalized # &mat &vx &vy &vz &vn => &x &y &z &n
    a=$x
    b=$y
    c=$z
    vi=${objects[idx+1]}
    vx=${vectors[$vi*4]}
    vy=${vectors[$vi*4+1]}
    vz=${vectors[$vi*4+2]}
    vn=${vectors[$vi*4+3]}
    matMultTransVecNormalized # &mat &vx &vy &vz &vn => &x &y &z &n
    terminalDrawLine  $b $a $y $x $c $cl $ch
    idx=$((idx+2))
  done
}

function plotPoly () { # &cl &ch &oi &last
  local idx vi vi vx vy vz vn ox oy oz on lx ly lz x y z
  idx=$oi
  # Keep track of first point
  vi=${objects[idx]}
  vx=${vectors[$vi*4]}
  vy=${vectors[$vi*4+1]}
  vz=${vectors[$vi*4+2]}
  vn=${vectors[$vi*4+3]}
  matMultTransVecNormalized # &mat &vx &vy &vz &vn => &x &y &z &n
  ox=$x
  oy=$y
  oz=$z
  lx=$ox
  ly=$oy
  lz=$oz
  idx=$((idx+1))
  while [ $idx -lt $last ]; do # over every vector index in object
    vi=${objects[idx]}
    vx=${vectors[$vi*4]}
    vy=${vectors[$vi*4+1]}
    vz=${vectors[$vi*4+2]}
    vn=${vectors[$vi*4+3]}
    matMultTransVecNormalized # &mat &vx &vy &vz &vn => &x &y &z &n
    terminalDrawLine  $ly $lx $y $x $lz $cl $ch
    lx=$x
    ly=$y
    lz=$z
    idx=$((idx+1))
  done
  terminalDrawLine  $y $x $oy $ox $z $cl $ch
}

function plotPoints () { # &oi &cl &ch &last &mi
  local idx=$oi vi vx vy vz vn x y zn
  while [ $idx -lt $last ]; do # over every vector index in object
    vi=${objects[idx]} # Vector index in vectors array
    vx=${vectors[$vi*4]}
    vy=${vectors[$vi*4+1]}
    vz=${vectors[$vi*4+2]}
    vn=${vectors[$vi*4+3]}
    matMultTransVecNormalized # &mi &vx &vy &vz &vn => &x &y &z
    terminalIsInScreen $x $y && echo $((x+TWIDTH2)) $((y+THEIGHT2)) $z $cl $ch
    idx=$((idx+1))
  done
}



##
## Globals
##
powerButton=true
jiffy=$SECONDS 
frame=0
framestop=60
sigwinch=false



##
## Rendering and Scheduling
##
screenBufferEmpty=""
depthBufferEmpty=""

function resetEmptyBuffers {
  screenBufferEmpty="$(printf "%.s' ' "  $(range 1 $((TWIDTH*THEIGHT))))"
  depthBufferEmpty="$(printf "%.s9999 " $(range 1 $((TWIDTH*THEIGHT))))"
}

function renderObjectSet { # &oil
 trap : SIGINT
 trap : SIGQUIT
 trap : SIGWINCH
 local oi type cl ch count last mi
 for oi in ${oil[*]}; do
    type=${objects[oi+1]}
    cl=${objects[oi+2]}
    ch=${objects[oi+3]}
    mi=$((16*${objects[oi+4]}))
    count=${objects[oi+6]}
    oi=$((oi+7))
    last=$((count + oi)) # compute index of last element in this object
      case $type in # &cl &ch &oi &last &mi
       (p) plotPoints ;;
       (l) plotLines ;;
       (y) plotPoly ;;
      esac
 done
 echo "q"
}

function scheduleObjectRenderers { # &frame &thread
  local max=${#objects[*]} oi=0 oil=() oilc=0 
  # over all objects
  while [ $oi -lt $max ]; do
    #symbol=${objects[oi+0]}
    type=${objects[oi+1]}
    cl=${objects[oi+2]}
    ch=${objects[oi+3]}
    plane=${objects[oi+5]}
    count=${objects[oi+6]}
    oi=$((oi+7))
    last=$((count + oi)) # compute index of last element in this object
    if [ ${facing[plane]} -eq 0 ]; then
      oil[oilc]=$((oi-7))
      oilc=$((oilc+1))
      if [ 8 -lt $oilc ]; then # more things happen per thread the higher this number is
        thread=$((thread+1))
        renderObjectSet > "${frame}_$thread" & # &oil
        oil=()
        oilc=0
      fi fi
    oi=$last # Skip object index to next object in array
  done

  if [ 0 -lt $oilc ]; then # Run any threads in the partially full list
    thread=$((thread+1))
    renderObjectSet > "${frame}_$thread" & # &oil
  fi
}


function doNormals { # &mat
  local i=2 # skip the first two fixed normal bools
  local max=$(planesLength)
  while [ $i -lt $max ]; do
    isPlaneFacing ${planes[i*2]} ${planes[i*2+1]}
    facing[i]=$?
    i=$((i+1))
  done
}

function fillDepthBuffer { # &frame &thread &screenBuffer &depthBuffer
  # clear the screen buffer
  local idx x y z k c i=0
  for filename in $(prerange ${frame}_ 1 $thread); do
    while [ ! -e $filename ]; do
      #1<&2 echo "ERROR: $filename doesn't exist."
      #sleep 1
      spin=$((spin+1))
    done # spin until the file is created
    while :; do
      read x y z k c
      if [ -z "$x" ]; then
        #1<&2 echo "ERROR: nothing read from $filename"
        #sleep 1
        spin=$((spin+1))
        continue
      fi
      [ "$x" == q ] && break
        idx=$((x+y*TWIDTH))
        if [ $z -lt ${depthBuffer[idx]} ]; then
          screenBuffer[idx]="[${COLORS[k]}m$c"
          depthBuffer[idx]=$z
        fi
    done <"$filename"
    rm $filename # Remove the files the rendering processes created
    i=$((i+1))
  done
}

function dumpStats {
  # parent: facing thread
  if [ $SECONDS -ne 0 ]; then
    frameRate=$((100*frame/(SECONDS)))
    PC 8 "\e[$((THEIGHT-4))Hframe:$frame\nfps:$((frameRate/100)).$((frameRate%100))\nthreads:$thread\nspins:$spin"
  fi
}

matrixPerspective=$(matMultNTrans $(matPerspective 60) $(matTrans 0 0 100) $(matScale 1 1 1))
#matrixPerspective="$matIdent"

matSetGlobal 0  $(matMultNTrans $matrixPerspective $(matRotx -6) )

function renderObjects {
  local thread=0 screenBuffer depthBuffer spin=0
  #[ $sec == 0 ] || [ "$1" == -resetCritters ] && resetCritters # Animal glyphs reset every minute or screen resize. 
  ## Global xform matrix
  #matSetGlobal 0  $(matMultNTrans $matrixPerspective $(matRotx -6) $(matRoty -$frame) )
  #matSetGlobal 0 $(matMultNTrans $matrixPerspective $(matRotz $((frame))) $(matRotx $((frame))) $(matRoty $((frame))) $(matTrans 0 0 0) )
  matTransformStatic
  doNormals
  scheduleObjectRenderers # &frame &thread -- Creates files with "x y z k c" per line
  if [ $thread != 0 ]; then
    eval screenBuffer=($screenBufferEmpty)
    depthBuffer=($depthBufferEmpty)
    if :; then
      trap : SIGINT
      trap : SIGQUIT
      trap : SIGWINCH
      fillDepthBuffer # &frame &thread &screenBuffer &depthBuffer &spin
      IFS=''
      printf "\e[H${screenBuffer[*]}$(dumpStats)" # &thread
      unset IFS
    fi &
  fi
  frame=$((frame+1))
}


##
## Build Models
##
ret=0
clockMid=0
clockIdx=0
clockRadius=10
matAppend $matIdent;  clockMid=$ret
function buildClock {
  local r=$1 s=$((- $1)) face=$2 tr idx nidx ret
  local b=$((r+0))
  shift 2
  clockRadius=$r
  case $face in
   (0) tr=$(matMultNTrans $(matRoty  0) $(matTrans 0 0 -$b)) ;;
   (1) tr=$(matMultNTrans $(matRoty 30) $(matTrans 0 0 -$b)) ;;
   (2) tr=$(matMultNTrans $(matRoty 60) $(matTrans 0 0 -$b)) ;;
   (3) tr=$(matMultNTrans $(matRoty 90) $(matTrans 0 0 -$b)) ;;
   (4) tr=$(matMultNTrans $(matRotx 30) $(matTrans 0 0 -$b)) ;;
   (5) tr=$(matMultNTrans $(matRotx 90) $(matTrans 0 0 -$b)) ;;
  esac

  # plane vectors for normal calculatoin.
  # The first three vectors will be used to calculate the culling normal for the entire clock.
  vectorsAppend  $(matMultTransNVec $tr  0 0 0 1   $r 0 0 1   0 $s 0 1)
  vidx=$ret # The index to these vectors is used a bunch of times
  planesAppend $vidx $clockMid # Register the vectors index of these three points
  pidx=$ret # Keep track of this plane's index as it's used by all the objects on this plane

  vectorsAppend  $(matMultTransNVec $tr  0 $s 0 1   $r 0 0 1   $r $r 0 1)
  objectsAdd HOUR l 6 _  $clockMid $pidx $vidx $((ret))
  objectsAdd MIN  l 2 _  $clockMid $pidx $vidx $((ret+1))
  objectsAdd SEC  l 5 _  $clockMid $pidx $vidx $((ret+2))

  vectorsAppend  $(matMultTransNVec $tr  $s $s 0 1  $r $s 0 1   $r $r 0 1  $s $r 0 1 )
  objectsAdd BOX  y $((face+1)) . $clockMid $pidx $((ret)) $((ret+1)) $((ret+2)) $((ret+3))

  for s in 10 20 30 40 50 60 70 80 90 100 110; do
    vectorsAppend $(matMultTransNVec $(matMultNTrans $tr $(matRotz $s))  0 $((r/2)) 0 1   0 $r 0 1)
    objectsAdd TICK l 7 . $clockMid $pidx $ret $((ret + 1))
  done
}

function updateClock {
  #timeProbe # $((frame*483))
  #vectors[(clockIdx+3)*4+0]=$((COSTABLE[(hour+90)%120]*clockRadius/240))
  #vectors[(clockIdx+3)*4+1]=$((SINTABLE[(hour+90)%120]*clockRadius/240))
  #vectors[(clockIdx+4)*4+0]=$((COSTABLE[(min+90)%120]*clockRadius/120))
  #vectors[(clockIdx+4)*4+1]=$((SINTABLE[(min+90)%120]*clockRadius/120))
  #vectors[(clockIdx+5)*4+0]=$((COSTABLE[(sec+90)%120]*clockRadius/120))
  #vectors[(clockIdx+5)*4+1]=$((SINTABLE[(sec+90)%120]*clockRadius/120))
  matSet $clockMid $(matRoty -$frame)
}




function buildTexturedCubes {
  local r=$1 # radius of the cubes
  local s=$2 # distance between cubes
  local d=$3 # density of the cubes
  local ret vidx0 vidx1 vidx2 vidx3 vidx4 vidx5

  # Generate the plane and textured points
  local  x  y=$((-r/d-0)) i=12
  local tf=($y $y 0 1   $y $((r/d-1)) 0 1   $((r/d-1)) $y 0 1) # normal plane
  while [ $y -le $((r/d)) ]; do
    x=$((-r/d-0))
    while [ $x -le $((r/d)) ]; do
      tf[i]=$((d*x))
      tf[i+1]=$((d*y))
      tf[i+2]=0
      tf[i+3]=1
      i=$((i+4))
      x=$((x+1))
    done
    y=$((y+1))
  done

  local tflen=$((${#tf[*]}/4))

  # Generate and register the vertices of each face forming the box model
  vectorsAppend $(matMultTransNVec $(matMultNTrans $(matRoty  0) $(matTrans 0 0 -$r)) ${tf[*]}); vidx0=$ret
  vectorsAppend $(matMultTransNVec $(matMultNTrans $(matRoty 30) $(matTrans 0 0 -$r)) ${tf[*]}); vidx1=$ret
  vectorsAppend $(matMultTransNVec $(matMultNTrans $(matRoty 60) $(matTrans 0 0 -$r)) ${tf[*]}); vidx2=$ret
  vectorsAppend $(matMultTransNVec $(matMultNTrans $(matRoty 90) $(matTrans 0 0 -$r)) ${tf[*]}); vidx3=$ret
  vectorsAppend $(matMultTransNVec $(matMultNTrans $(matRotx 30) $(matTrans 0 0 -$r)) ${tf[*]}); vidx4=$ret
  vectorsAppend $(matMultTransNVec $(matMultNTrans $(matRotx 90) $(matTrans 0 0 -$r)) ${tf[*]}); vidx5=$ret

  function buildTexturedCube { # (midx)
    local midx=$1
    local ret # the transformation matrix index for the normal plane
    planesAppend $vidx0 $midx
    objectsAdd FACE0 p 1 @ $midx $ret $(range $((vidx0+3)) $((vidx0+$tflen-1)))
    planesAppend $vidx1 $midx
    objectsAdd FACE1 p 2 @ $midx $ret $(range $((vidx1+3)) $((vidx1+$tflen-1)))
    planesAppend $vidx2 $midx
    objectsAdd FACE2 p 3 @ $midx $ret $(range $((vidx2+3)) $((vidx2+$tflen-1)))
    planesAppend $vidx3 $midx
    objectsAdd FACE3 p 4 @ $midx $ret $(range $((vidx3+3)) $((vidx3+$tflen-1)))
    planesAppend $vidx4 $midx
    objectsAdd FACE4 p 5 @ $midx $ret $(range $((vidx4+3)) $((vidx4+$tflen-1)))
    planesAppend $vidx5 $midx
    objectsAdd FACE5 p 6 @ $midx $ret $(range $((vidx5+3)) $((vidx5+$tflen-1)))
  }

  # These 6 matrices will affect each of the cube objects
  matAppend $(matTrans -$s 10   0);  mymat=$ret;  buildTexturedCube $ret
  matAppend $(matTrans   0 10  $s);  buildTexturedCube $ret
  matAppend $(matTrans   0 10 -$s);  buildTexturedCube $ret
  matAppend $(matTrans  $s 10   0);  buildTexturedCube $ret
  mys=$s
} # buildTexturedCubes

mys=0
mymat=0
function updateBoxes {
  matSet $((mymat+0)) $(matMultNTrans $(matRoty $frame) $(matTrans -$mys 10   0) $(matRotz $((frame*3))))
  matSet $((mymat+1)) $(matMultNTrans $(matRoty $frame) $(matTrans 0   10  $mys) $(matRotz $((frame*3))))
  matSet $((mymat+2)) $(matMultNTrans $(matRoty $frame) $(matTrans 0   10 -$mys) $(matRotz $((frame*3))))
  matSet $((mymat+3)) $(matMultNTrans $(matRoty $frame) $(matTrans $mys  10   0) $(matRotz $((frame*3))))
}


function buildFloor {
  local ret
  local r=$1 # radius of the cubes
  local s=$2 # floor height
  local d=$3 # density of the cubes

  function buildTexturedFace {
    local  x  z=$((-r/d))
    #echo 0 0 0 1  0 0 0 1  0 0 0 1
    while [ $z -le $((r/d)) ]; do
      x=$((-r/d))
      while [ $x -le $((r/d)) ]; do
        echo -n "$((d*x)) 0 $((d*z)) 1 "
        x=$((x+1))
      done
      z=$((z+1))
    done
  }
  vectorsAppend $(matMultTransNVec $(matTrans 0 $s 0) $(buildTexturedFace))
  objectsAdd FLOOR p 8 . 0 1 $(range $((ret+3)) $((ret+$(( $(vectorsLength) - ret - 1)))))
}



function buildSimpleBox {
  # (1) Create the points
  local ret r=$1 idx
  vectorsAppend -$r $r $r 1  $r $r $r 1  $r -$r $r 1  -$r -$r $r 1   -$r $r -$r 1  $r $r -$r 1  $r -$r -$r 1  -$r -$r -$r 1
  objectsAdd POINTS p 3 x 0 1  $(eval echo {$ret..$((ret+7))})
  objectsAdd BOX   y 6 + 0 1  $(range $ret $((ret+3)))  # back
  objectsAdd BOX   y 6 + 0 1  $(range $((ret+4)) $((ret+7)))  # front
  objectsAdd EDGES l 6 + 0 1  $((ret+1)) $((ret+5))  $((ret+2)) $((ret+6))  $((ret+3)) $((ret+7))  $((ret+4)) $ret
  r=$((r/2))
  vectorsAppend -$r $r $r 1  $r $r $r 1  $r -$r $r 1  -$r -$r $r 1   -$r $r -$r 1  $r $r -$r 1  $r -$r -$r 1  -$r -$r -$r 1
  objectsAdd POINTS y 2 y 1  $(range $((ret+0)) $((ret+7)))
}

function buildUrchin {
  local origin ret c=$1 r=$2 glyphs=('.' '+' '@' 'x' 'o' '-')

  while [ 0 -lt $c ]; do
    vectorsAppend $(matMultTransNVec $(matMultNTrans $(matTrans 0 0 0) $(matRotx $((RANDOM%120))) $(matRoty $((RANDOM%120))) $(matRotz $((RANDOM%120))) ) $((r/2)) 0 0 1 $r 0 0 1)
    objectsAdd LINE l $((RANDOM%15+1)) ${glyphs[c%6]} 0 1 $ret $((ret+1))
   c=$((c-1))
  done
}




##
## Exception handlers
##
function handler_sigint { powerButton=false; }
function handler_sigwinch { sigwinch=true; }


##
## USAGE:  basciiclock [a|b] {frame count}
##
function main {
  framestop=${1:--1}
  trap handler_sigint   SIGINT
  trap handler_sigint   SIGQUIT
  trap handler_sigwinch SIGWINCH
  printf "\e[?25l\e[0m" # Disable cursor
  terminalProbe
  resetEmptyBuffers
  resetCritters

  #buildUrchin 50 90
  #buildSimpleBox 70
  buildTexturedCubes 10 80 5
  buildFloor 80 40 8
  if :; then
    buildClock 30 0 4
    buildClock 30 1 4
    buildClock 30 2 4
    buildClock 30 3 4
    buildClock 30 4 4
    buildClock 30 5 4
  fi
  #vectorsDump
  #objectsDump
  #planesDump
  #matDump
  #read -n 1 -p 'Abort, Retry, Fail?' k
  while [ ! -e stop ] && $powerButton && [ $frame -ne $framestop ] ; do
    if [ $jiffy != $SECONDS ]; then
      timeProbe # $((frame*483))
      jiffy=$SECONDS
    fi
    if $sigwinch; then
      echo handler
      wait
      terminalProbe
      resetEmptyBuffers
      sigwinch=false
    fi
    renderObjects
    updateClock
    updateBoxes
  done
  wait
  printf "\e[?25h\nDone.\n" # Enable cursor
}

time main -10 # Run indefinitely or until ^C
