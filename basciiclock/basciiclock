#!/bin/bash

##
## Poor man's console 3d lib
##

# Concepts:
#
#  * Vectors and matrices are just bash arrays and passed by value as individual args or quoted args.
#  * Everything's fixed point because bash math has no floating math support.
#  * Unit circle radius=120
#  * Radian SINTABLE 120 in size
#  * Presume +Z extends beyond screen away from viewer.
#
# Notes:
#
#  Although you can pass an array as a symbolic reference to a function as 'ary[@]' then
#  copy it locally with myary=(${!1}), it's faster just to pass the array around
#  as an expanded list of values "${ary[*]}" and copied locally with myary=($1) or just
#  used directly and consumed along with shift which seems to be the fastest.

CSI=$'\e['

SINTABLE=(0 6 12 18 25 31 37 43 49 54 60 65 70 75 80 85 89 93 97 101 104 107 110 112 114 116 117 119 119 120 120 120 119 119 117 116 114 112 110 107 104 101 97 93 89 85 80 75 70 65 60 54 49 43 37 31 25 18 12 6 0 -6 -12 -18 -25 -31 -37 -43 -49 -54 -60 -65 -70 -75 -80 -85 -89 -93 -97 -101 -104 -107 -110 -112 -114 -116 -117 -119 -119 -120 -120 -120 -119 -119 -117 -116 -114 -112 -110 -107 -104 -101 -97 -93 -89 -85 -80 -75 -70 -65 -60 -54 -49 -43 -37 -31 -25 -18 -12 -6)
COSTABLE=(120 120 119 119 117 116 114 112 110 107 104 101 97 93 89 85 80 75 70 65 60 54 49 43 37 31 25 18 12 6 0 -6 -12 -18 -25 -31 -37 -43 -49 -54 -60 -65 -70 -75 -80 -85 -89 -93 -97 -101 -104 -107 -110 -112 -114 -116 -117 -119 -119 -120 -120 -120 -119 -119 -117 -116 -114 -112 -110 -107 -104 -101 -97 -93 -89 -85 -80 -75 -70 -65 -60 -54 -49 -43 -37 -31 -25 -18 -12 -6 0 6 12 18 25 31 37 43 49 54 60 65 70 75 80 85 89 93 97 101 104 107 110 112 114 116 117 119 119 120)

function hex { printf %x $1; }
function aoctopus { printf "\xf0\x9f\x90\x${1:-$(hex $((128+RANDOM%64)))}"; }

P    (){ printf %s $@ ; }
dv   (){ while [ 0 -lt $# ]; do printf '[%6d %6d %6d %6d]\n' $1 $2 $3 $4; shift 4; done; }
dvn  (){ while [ 0 -lt $# ]; do printf '[%6d %6d %6d %6d | %6d]\n' $(($1/$4)) $(($2/$4)) $(($3/$4)) $(($4/$4)) $4; shift 4; done; }
dm4  (){ printf '[%6d %6d %6d %6d]\n' $1 $2 $3 $4 $5 $6 $7 $8 $9 ${10} ${11} ${12} ${13} ${14} ${15} ${16}; }
dm4n (){ printf '[%6d %6d %6d %6d]\n' $(($1/$16)) $(($2/$16)) $(($3/$16)) $(($4/$16)) $(($5/$16)) $(($6/$16)) $(($7/$16)) $(($8/$16)) $(($9/$16)) $(($10/$16)) $(($11/$16)) $(($12/$16)) $(($13/$16)) $(($14/$16)) $(($15/$16)) $(($16/$16)); }
G2   (){ printf "\x1b[$(($1+THEIGHT2));$(($2+TWIDTH2))H$3"; }
COLORS=('0' '0;31' '0;32' '0;33' '0;34' '0;35' '0;36' '0;37' '1;30' '1;31' '1;32' '1;33' '1;34' '1;35' '1;36' '1;37')
function CL { local c=$1; shift; printf "\e[${COLORS[c]}m$*"; }


#
# Keep track of terminal dimensions.
#
TWIDTH=80
TWIDTH2=40
THEIGHT=25
THEIGHT2=13
function probeTerminal {
  read THEIGHT TWIDTH <<<$(stty size);
  THEIGHT2=$((THEIGHT/2))
  TWIDTH2=$((TWIDTH/2))
}


function inscreen { # x y
  local x=$(($1+TWIDTH2))
  local y=$(($2+THEIGHT2))
  if [ $x -lt 1 ] || [ $y -lt 1 ] || [ $TWIDTH -lt $x ] || [ $THEIGHT -lt $y ]; then
    return 1
  fi
  return 0
}


function line {
  local x y m n d dx dy w ws nx ny yyxx e i
  # Make sure line is drawn from left -x to right +x in the temrinal.
  if [ $2 -le $4 ]; then
    x=$2; y=$1; m=$4; n=$3
  else
    x=$4; y=$3; m=$2; n=$1
  fi
  # (x,y) to (m,n) will always go left to right
  dx=$((m-x))
  if [ $1 -lt $3 ]; then dy=$(($3-$1)); else dy=$(($1-$3)); fi

  # Always walk or walk-step

  if [ $dy -lt $dx ]; then # Small slope so walk left and step up or down
    w=''; xwi=1;  ywi=0
    if [ $y -lt $n ]; then # walk right and down
       ws=$'\v'; xwsi=1; ywsi=1
    else                   # walk right and up
       ws=$'\eM'; xwsi=1; ywsi=-1
    fi
    nx=$dx
    ny=$dy
  else # Large slope, so walk up or down and step right
    if [ $y -lt $n ]; then # walk down and right
       w=$'\b\v'; xwi=0; ywi=1
       ws=$'\v'; xwsi=1; ywsi=1
    else                   # walk up and right
       w=$'\b\eM'; xwi=0; ywi=-1
       ws=$'\eM'; xwsi=1; ywsi=-1
    fi
    nx=$dy
    ny=$dx
  fi

  # Valid state when drawing lines on the terminal
  #  0 = out
  #  1 = in
  state=0

  yy=$((ny + ny))
  yyxx=$((yy - nx - nx))
  e=$((yy - nx))
  i=$nx

  while [ 0 -lt $i ]; do
    if [ 0 -le $e ]; then
      if [ $state == 1 ]; then
        inscreen $x $y || return 0 # done if out of screen
        printf "$ws$5"
      else # state == 0
        inscreen $x $y && G2 $y $x "$5"
      fi
      x=$((x+xwsi)); y=$((y+ywsi))
      e=$((e + yyxx))
    else
      if [ $state == 1 ]; then
        inscreen $x $y || return 0 # done if out of screen
        printf "$w$5"
      else # state == 0
        inscreen $x $y && G2 $y $x "$5"
      fi
      x=$((x+xwi)); y=$((y+ywi))
      e=$((e + yy))
    fi
    i=$((i-1))
  done
}

# Scan hour, min, sec.  10# forces base 10 parsing of numbers beginning with 0
probetime (){ hour=$((10#$1 * 10)); min=$((10#$2 * 2)); sec=$((10#$3 * 2)); }
probetime $(date +'%H %M %S')

identity=(1 0 0 0  0 1 0 0   0 0 1 0  0 0 0 1)

#
# Create transformation matrices
#
function matRotz () { echo -n "${COSTABLE[$1%120]} $((- SINTABLE[$1%120])) 0 0 ${SINTABLE[$1%120]} ${COSTABLE[$1%120]} 0 0 0 0 120 0 0 0 0 120 "; }
function matRoty () { echo -n "${COSTABLE[$1%120]} 0 $((- SINTABLE[$1%120])) 0 0 120 0 0 ${SINTABLE[$1%120]} 0 ${COSTABLE[$1%120]} 0 0 0 0 120 "; }
function matRotx () { echo -n "120 0 0 0 0 ${COSTABLE[$1%120]} ${SINTABLE[$1%120]} 0 0   $((- SINTABLE[$1%120])) ${COSTABLE[$1%120]} 0 0 0 0 120 "; }
function matScale () { echo "$1 0 0 0  0 $2 0 0  0 0 $3 0  0 0 0 1 "; }
function matTrans () { echo "1 0 0 $1  0 1 0 $2  0 0 1 $3  0 0 0 1 "; }
function matPerspective () { echo "1000 0 0 0  0 1000 0 0  0 0 1000 0  0 0 $((1000/$1)) 1000 "; }

#
# Multiply 4x4 row vector (first arg) with 4xN column vector (remaining args).
#  Arg1 = 'a b c d  e f g h  i j k l  m n o p'
#  Arg* = x0 y0 z0 1  x1 y1 z1 1  ...
#
function matMult () {
 m=($1); shift
 while [ 0 -lt $# ]; do
    echo -n "$((m[0]*$1 + m[1]*$2 + m[2]*$3 + m[3]*$4))  $((m[4]*$1 + m[5]*$2 + m[6]*$3 + m[7]*$4))  $((m[8]*$1 + m[9]*$2 + m[10]*$3 + m[11]*$4))  $((m[12]*$1 + m[13]*$2 + m[14]*$3 + m[15]*$4)) "
    shift 4
 done
}

#
# Multiply N 4x4 row vectors
#  Arg1 = 'a b c d  e f g h  i j k l  m n o p'
#  Arg2 = x0 y0 z0 1  x1 y1 z1 1  ...
#
function matMultXform () {
 local m=($1); shift
 local n=($1); shift
 local mm=();
 while :; do
   mm[0]=$((m[0]*n[0] + m[1]*n[4] + m[2]*n[8] + m[3]*n[12]))
    mm[1]=$((m[0]*n[1] + m[1]*n[5] + m[2]*n[9] + m[3]*n[13]))
     mm[2]=$((m[0]*n[2] + m[1]*n[6] + m[2]*n[10] + m[3]*n[14]))
      mm[3]=$((m[0]*n[3] + m[1]*n[7] + m[2]*n[11] + m[3]*n[15]))
   mm[4]=$((m[4]*n[0] + m[5]*n[4] + m[6]*n[8] + m[7]*n[12]))
    mm[5]=$((m[4]*n[1] + m[5]*n[5] + m[6]*n[9] + m[7]*n[13]))
     mm[6]=$((m[4]*n[2] + m[5]*n[6] + m[6]*n[10] + m[7]*n[14]))
      mm[7]=$((m[4]*n[3] + m[5]*n[7] + m[6]*n[11] + m[7]*n[15]))
   mm[8]=$((m[8]*n[0] + m[9]*n[4] + m[10]*n[8] + m[11]*n[12]))
    mm[9]=$((m[8]*n[1] + m[9]*n[5] + m[10]*n[9] + m[11]*n[13]))
     mm[10]=$((m[8]*n[2] + m[9]*n[6] + m[10]*n[10] + m[11]*n[14]))
      mm[11]=$((m[8]*n[3] + m[9]*n[7] + m[10]*n[11] + m[11]*n[15]))
   mm[12]=$((m[12]*n[0] + m[13]*n[4] + m[14]*n[8] + m[15]*n[12]))
    mm[13]=$((m[12]*n[1] + m[13]*n[5] + m[14]*n[9] + m[15]*n[13]))
     mm[14]=$((m[12]*n[2] + m[13]*n[6] + m[14]*n[10] + m[15]*n[14]))
      mm[15]=$((m[12]*n[3] + m[13]*n[7] + m[14]*n[11] + m[15]*n[15]))
   [ 0 -eq $# ] && { echo ${mm[*]}; return 0; }
   n=($1); shift
   m[0]=$((mm[0]*n[0] + mm[1]*n[4] + mm[2]*n[8] + mm[3]*n[12]))
    m[1]=$((mm[0]*n[1] + mm[1]*n[5] + mm[2]*n[9] + mm[3]*n[13]))
     m[2]=$((mm[0]*n[2] + mm[1]*n[6] + mm[2]*n[10] + mm[3]*n[14]))
      m[3]=$((mm[0]*n[3] + mm[1]*n[7] + mm[2]*n[11] + mm[3]*n[15]))
   m[4]=$((mm[4]*n[0] + mm[5]*n[4] + mm[6]*n[8] + mm[7]*n[12]))
    m[5]=$((mm[4]*n[1] + mm[5]*n[5] + mm[6]*n[9] + mm[7]*n[13]))
     m[6]=$((mm[4]*n[2] + mm[5]*n[6] + mm[6]*n[10] + mm[7]*n[14]))
      m[7]=$((mm[4]*n[3] + mm[5]*n[7] + mm[6]*n[11] + mm[7]*n[15]))
   m[8]=$((mm[8]*n[0] + mm[9]*n[4] + mm[10]*n[8] + mm[11]*n[12]))
    m[9]=$((mm[8]*n[1] + mm[9]*n[5] + mm[10]*n[9] + mm[11]*n[13]))
     m[10]=$((mm[8]*n[2] + mm[9]*n[6] + mm[10]*n[10] + mm[11]*n[14]))
      m[11]=$((mm[8]*n[3] + mm[9]*n[7] + mm[10]*n[11] + mm[11]*n[15]))
   m[12]=$((mm[12]*n[0] + mm[13]*n[4] + mm[14]*n[8] + mm[15]*n[12]))
    m[13]=$((mm[12]*n[1] + mm[13]*n[5] + mm[14]*n[9] + mm[15]*n[13]))
     m[14]=$((mm[12]*n[2] + mm[13]*n[6] + mm[14]*n[10] + mm[15]*n[14]))
      m[15]=$((mm[12]*n[3] + mm[13]*n[7] + mm[14]*n[11] + mm[15]*n[15]))
   [ 0 -eq $# ] && { echo ${m[*]}; return 0; }
   n=($1); shift
 done
}

function isFacing () {

  # Apply perspective
  zz=$(($3/$4))
  zx=$(($1/$4))
  zy=$(($2/$4))

  z2=$(($7/$8))
  x2=$(($5/$8))
  y2=$(($6/$8))

  z3=$((${11}/${12}))
  x3=$(($9/${12}))
  y3=$((${10}/${12}))

  # Check Z component of the normal of the above two vectors
  va0=$((x2-zx))
  va1=$((y2-zy))
  vb0=$((x3-zx))
  vb1=$((y3-zy))
  [ $((va0*vb1 - va1*vb0)) -lt 0 ]
}


function plotLines () {
  local ch=$1; shift  ## character to plot
  while [ 0 -lt $# ]; do
    # Normalize
    x=$(($1/$4))
    y=$(($2/$4))
    z=$(($3/$4))

    x1=$(($5/$8))
    y1=$(($6/$8))
    z1=$(($7/$8))

    [ 0 -lt $z ] && [ 0 -lt $z1 ] && {
      line  $y $x $y1 $x1 "$ch"
    }
    shift 8
  done
}

function plotPoly () {
  local x y z sx sy sz lx ly lz
  local ch=$1; shift  ## character to plot

   #Start point
   x=$(($1/$4))
   y=$(($2/$4))
   z=$(($3/$4))
   shift 4

   sx=$x
   sy=$y # remember this as last point
   sz=$z

   lx=$x
   ly=$y # last coordinate
   lz=$z

  while [ 0 -lt $# ]; do
    x=$(($1/$4))
    y=$(($2/$4)) # next point
    z=$(($3/$4))

    [ 0 -lt $lz ] && [ 0 -lt $z ] && {
      line  $ly $lx $y $x "$ch"
    }
    lx=$x
    ly=$y # last point
    lz=$z

    shift 4
  done
  [ 0 -lt $sz ] && [ 0 -lt $lz ] && {
    line $ly $lx $sy $sx "$ch"
  }
}

function plotPoints () {
  local x y z ch i=0 ary="NOMINUM"
  ch=$1; shift # character to plot
  while [ 0 -lt $# ]; do
     # Normalize
     x=$(($1/$4))
     y=$(($2/$4))
     z=$(($3/$4))
     if [ 0 -lt $z ]; then
       G2 $y $x ${ary:i:1}
       i=$((i+1))
       [ $i -lt ${#ary} ] || i=0
     fi
    shift 4
  done
}

function resetAnimals {
  animal1=$(aoctopus)
  animal2=$(aoctopus)
  animal3=$(aoctopus)
}
resetAnimals


# makeLine mat a b c x y z
function transformPoints {
  mat="$1"; shift
  matMult "$mat" $*
}

# Object descriptor and vertex stores
glables=()
gpoints=()

r=20

# Keep track of sets of points
function makePoints {
  local len=${#gpoints[*]}
  glabels=("${glabels[@]}" "$1 $2 $3 $4 $len $((len+$#-4))")
  shift 4
  gpoints=(${gpoints[@]} $*)
}

# These three non-displayed points define two vectors that
# are used to compute the "is facing us" normal vector.
normalBasis="-$r $r 0 1  $r $r 0 1  -$r -$r 0 1"


# Transformation matrices that orient a face to either of the 6 cube faces.
matrixCubeFacea=$(matMultXform "$(matRoty 0)"  "$(matTrans 0 0 -$r)")
matrixCubeFaceb=$(matMultXform "$(matRoty 30)" "$(matTrans 0 0 -$r)")
matrixCubeFacec=$(matMultXform "$(matRoty 60)" "$(matTrans 0 0 -$r)")
matrixCubeFaced=$(matMultXform "$(matRoty 90)" "$(matTrans 0 0 -$r)")
matrixCubeFacee=$(matMultXform "$(matRotx 30)" "$(matTrans 0 0 -$r)")
matrixCubeFacef=$(matMultXform "$(matRotx 90)" "$(matTrans 0 0 -$r)")

box="$normalBasis   $r -$r 0 1    -$r -$r 0 1    -$r $r 0 1    $r $r 0 1"

boxa=$(transformPoints "$matrixCubeFacea" $box)
boxb=$(transformPoints "$matrixCubeFaceb" $box)
boxc=$(transformPoints "$matrixCubeFacec" $box)
boxd=$(transformPoints "$matrixCubeFaced" $box)
boxe=$(transformPoints "$matrixCubeFacee" $box)
boxf=$(transformPoints "$matrixCubeFacef" $box)



function buildClockCube {
  function makeHand { echo 0 $((-$1*r/10)) 0 1  0 $((-$2*r/10)) 0 1; }
  twelve="$(echo  $normalBasis; makeHand 2 7)"
  myclock="$(echo $normalBasis; for s in 10 20 30 40 50 60 70 80 90 100 110; do transformPoints "$(matRotz s)" $(makeHand 2 7); done )"
  mymin="$(echo   $normalBasis; transformPoints "$(matRotz              $min)" $(makeHand 0 7))"
  myhour="$(echo  $normalBasis; transformPoints "$(matRotz  $((hour+min/12)))" $(makeHand 2 4))"
  mysec="$(echo   $normalBasis; transformPoints "$(matRotz              $sec)" $(makeHand 6 7))"

  makePoints A        \# 9 y $boxa
  makePoints clock    \. 8 l  $(transformPoints "$matrixCubeFacea" $myclock)
  makePoints twelve   \. 15 l $(transformPoints "$matrixCubeFacea" $twelve)
  makePoints handmin  $animal1 6 l $(transformPoints "$matrixCubeFacea" $mymin)
  makePoints handhour $animal2 2 l $(transformPoints "$matrixCubeFacea" $myhour)
  makePoints handsec  $animal3 5 l $(transformPoints "$matrixCubeFacea" $mysec)

  makePoints B        \# 10 y $boxb
  makePoints clock    \. 8  l $(transformPoints "$matrixCubeFaceb" $myclock)
  makePoints twelve   \. 15 l $(transformPoints "$matrixCubeFaceb" $twelve)
  makePoints handmin  $animal1 6  l $(transformPoints "$matrixCubeFaceb" $mymin)
  makePoints handhour $animal2 2  l $(transformPoints "$matrixCubeFaceb" $myhour)
  makePoints handsec  $animal3 5  l $(transformPoints "$matrixCubeFaceb" $mysec)

  makePoints C        \# 12 y $boxc
  makePoints clock    \. 8  l $(transformPoints "$matrixCubeFacec" $myclock)
  makePoints twelve   \. 15 l $(transformPoints "$matrixCubeFacec" $twelve)
  makePoints handmin  $animal1 6  l $(transformPoints "$matrixCubeFacec" $mymin)
  makePoints handhour $animal2 2  l $(transformPoints "$matrixCubeFacec" $myhour)
  makePoints handsec  $animal3 5  l $(transformPoints "$matrixCubeFacec" $mysec)

  makePoints D        \# 14 y $boxd
  makePoints clock    \. 8  l $(transformPoints "$matrixCubeFaced" $myclock)
  makePoints twelve   \. 15 l $(transformPoints "$matrixCubeFaced" $twelve)
  makePoints handmin  $animal1 6  l $(transformPoints "$matrixCubeFaced" $mymin)
  makePoints handhour $animal2 2  l $(transformPoints "$matrixCubeFaced" $myhour)
  makePoints handsec  $animal3 5  l $(transformPoints "$matrixCubeFaced" $mysec)

  makePoints E        \# 11 y $boxe
  makePoints clock    \. 8  l $(transformPoints "$matrixCubeFacee" $myclock)
  makePoints twelve   \. 15 l $(transformPoints "$matrixCubeFacee" $twelve)
  makePoints handmin  $animal1 6  l $(transformPoints "$matrixCubeFacee" $mymin)
  makePoints handhour $animal2 2  l $(transformPoints "$matrixCubeFacee" $myhour)
  makePoints handsec  $animal3 5  l $(transformPoints "$matrixCubeFacee" $mysec)

  makePoints F        \# 13 y $boxf
  makePoints clock    \. 8  l $(transformPoints "$matrixCubeFacef" $myclock)
  makePoints twelve   \. 15 l $(transformPoints "$matrixCubeFacef" $twelve)
  makePoints handmin  $animal1 6  l $(transformPoints "$matrixCubeFacef" $mymin)
  makePoints handhour $animal2 2  l $(transformPoints "$matrixCubeFacef" $myhour)
  makePoints handsec  $animal3 5  l $(transformPoints "$matrixCubeFacef" $mysec)
}



function buildTexturedCube {
  function buildTexturedFace {
    echo $normalBasis
    d=5
    y=$((-r/d))
    while [ $y -le $((r/d)) ]; do
      x=$((-r/d))
      while [ $x -le $((r/d)) ]; do
        echo -n "$((d*x)) $((d*y)) 0 1 "
        x=$((x+1))
      done
      y=$((y+1))
    done
  }
  makePoints A a 4 p $(transformPoints "$matrixCubeFacea" $(buildTexturedFace))
  makePoints B b 5 p $(transformPoints "$matrixCubeFaceb" $(buildTexturedFace))
  makePoints C c 6 p $(transformPoints "$matrixCubeFacec" $(buildTexturedFace))
  makePoints D d 7 p $(transformPoints "$matrixCubeFaced" $(buildTexturedFace))
  makePoints E e 3 p $(transformPoints "$matrixCubeFacee" $(buildTexturedFace))
  makePoints F f 2 p $(transformPoints "$matrixCubeFacef" $(buildTexturedFace))
}



#
# Globals
#
powerButton=true
frame=0 # Final plotting scale
matrixGlobal=()  # Global transformation matrix
startTime=$(($(date +%s)-1))
matrixPerspective=$(matMultXform "$(matPerspective 30)" "$(matTrans 0 0 70)" "$(matScale 2 2 2)")



function renderEachObject {
  local fileIndex=0
  for l in "${glabels[@]}"; do
    read n c k t a b <<<$l
    if isFacing $(matMult "${matrixGlobal[*]}" ${gpoints[*]:$a:12}); then
      fileIndex=$((fileIndex+1))
      {
        CL $k
        case $t in 
         (y) plotPoly   "$c" $(matMult "${matrixGlobal[*]}" ${gpoints[*]:$a+12:$b-$a-12})  ;;
         (l) plotLines  "$c" $(matMult "${matrixGlobal[*]}" ${gpoints[*]:$a+12:$b-$a-12})  ;;
         (p) plotPoints "$c" $(matMult "${matrixGlobal[*]}" ${gpoints[*]:$a+12:$b-$a-12})  ;;
        esac
      } >$fileIndex &
    fi
  done
  wait # for all the rendering child processes to finish

  frame=$((frame+1))
  frameRate=$((100*frame/($(date +%s)-startTime)))

  P $CSI 2J
  cat $(eval "echo {1..$fileIndex}")
  CL 8 "${CSI}H$((frameRate/100)).$((frameRate%100))"

  rm $(eval "echo {1..$fileIndex}")
}


function renderclock {

  # Recompute models.  They might be time dependent like a real-time analog clock.
  glabels=()
  gpoints=()
  buildClockCube
  #buildTexturedCube

  # Rest animal chracters every minute or screen resize.
  [ $sec == 0 ] || [ "$1" == -resetAnimals ] && resetAnimals
  matrixGlobal=($(matMultXform "$matrixPerspective" "$(matRotx $((frame/3)))" "$(matRoty $frame)"))
  renderEachObject
}

function handle_sigint {
  powerButton=false
}

function handle_sigwinch {
  probeTerminal
  renderclock -resetAnimals
}

function main {
  P $CSI?25l # Disable cursor
  probeTerminal
  resetAnimals
  trap handle_sigint   SIGINT
  trap handle_sigwinch SIGWINCH
  case $1 in (a)
    while $powerButton; do
      if [ "$currentTick" != $(date +%s) ]; then
        probetime $(date +'%H %M %S')
        renderclock
        currentTick=$(date +%s)
      fi
      sleep .9
    done
  ;; (b)
    while $powerButton; do
    #for a in {1..90}; do 
      #probetime $(date -r $frame +'%H %M %S')
      probetime $(date +'%H %M %S')
      renderclock
      frame=$((frame+1))
    done
  ;; esac
}

main b
