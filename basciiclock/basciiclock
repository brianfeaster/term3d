#!/bin/bash

#### Poor man's console 3d lib
## _Concepts_
## _Testing_
## _Planes_

#### _Concepts_
##
##  * Vectors and matrices are arrays and passed by value as individual args, a
##    quoted expanded list, or referenced directly by the callee due to
##    function's dynamic scoping.
##  * Everything's fixed point because bash math has no floating math support.
##  * Unit circle radius=120
##  * Radian SINTABLE 120 in size
##  * Presume +Z extends beyond screen away from viewer.
##
## Arrays vs function arguments:
##
##  Although you can pass an array as a symbolic reference to a function as 'ary[@]'
##  then copy it locally with myary=(${!1}), it's faster just to pass the array around
##  as an expanded list of values "${ary[*]}" and copied locally with myary=($1) or
##  just used directly and consumed along with shift which seems to be the fastest.
##  Relying on dynamic scoping is event faster.
##
##  Implementing matrix multiply with a dynamic scopped target matrix isn't any
##  faster than passing all the elements as args and returning the matrix symbolically.
##
## Depth-buffer
##
##  Up until now the z coordinate has been ignored as a form of 2d projection.  Now it
##  needs to be considered when determining depth for inclusion into the the z-buffer
##  array.  The line drawing algorithm will just compute the z coordinate given either
##  the x (slope between -1 and 1) or y (slope beyond -1 or 1).  There may be a DDA
##  method that will be faster but for now this should suffice.
##
## Frame-Buffer
##
##  The terminal can't be written to directly now.  Instead 3d coordinates and
##  character the character/color will will be generated for all visible 'points'
##  then all used to populate the depth buffer.
##
## Model Store
##
##  Replace below with something that registers points (which may move) and faces that can be drawn from said points
##  The first three points of the face defines two vectors for normal computation
##    points: a b c d  e f g h ...
##    faces:  0 1 2 3  4 5 6 7  1 0 4 5  1 2 5 6 ...
##    norm:   0 1 3    4 5 7    1 0 5
##
##  Each vertex and model will be stored in global lists.  Another mechanism will be
##  used to apply copying transformations to the vertices in the global list.  The
##  renderer shouldn't care.
##
## Normal Lists
##
##  Objects that share a facing normal will share a common normal to be transformed
##  and calculated en masse prior to scheduling the rest of the rendering.
##
####


#### _Testing_
##
function assertEquals {
  IFS=''
  local title="$1" res="$2" exp="$3"
  #echo -e "\e[32m$1\n\e[0;31m$2\e[0m"
  if [ "$res" != "$exp" ]; then
    echo -e "\e[31;1m[FAIL] $title\e[0;33m"
    diff <(echo $res) <(echo $exp)
    echo -e "\e[0m"
    exit $?
  fi
  unset IFS
}
#### _Testing_



##
## Math stuff.  Mappings from [0..120] -> [-120..120]
##
SINTABLE=(0 6 12 18 25 31 37 43 49 54 60 65 70 75 80 85 89 93 97 101 104 107 110 112 114 116 117 119 119 120 120 120 119 119 117 116 114 112 110 107 104 101 97 93 89 85 80 75 70 65 60 54 49 43 37 31 25 18 12 6 0 -6 -12 -18 -25 -31 -37 -43 -49 -54 -60 -65 -70 -75 -80 -85 -89 -93 -97 -101 -104 -107 -110 -112 -114 -116 -117 -119 -119 -120 -120 -120 -119 -119 -117 -116 -114 -112 -110 -107 -104 -101 -97 -93 -89 -85 -80 -75 -70 -65 -60 -54 -49 -43 -37 -31 -25 -18 -12 -6)
SINTABLEI=(0 -6 -12 -18 -25 -31 -37 -43 -49 -54 -60 -65 -70 -75 -80 -85 -89 -93 -97 -101 -104 -107 -110 -112 -114 -116 -117 -119 -119 -120 -120 -120 -119 -119 -117 -116 -114 -112 -110 -107 -104 -101 -97 -93 -89 -85 -80 -75 -70 -65 -60 -54 -49 -43 -37 -31 -25 -18 -12 -6 0 6 12 18 25 31 37 43 49 54 60 65 70 75 80 85 89 93 97 101 104 107 110 112 114 116 117 119 119 120 120 120 119 119 117 116 114 112 110 107 104 101 97 93 89 85 80 75 70 65 60 54 49 43 37 31 25 18 12 6)
COSTABLE=(120 120 119 119 117 116 114 112 110 107 104 101 97 93 89 85 80 75 70 65 60 54 49 43 37 31 25 18 12 6 0 -6 -12 -18 -25 -31 -37 -43 -49 -54 -60 -65 -70 -75 -80 -85 -89 -93 -97 -101 -104 -107 -110 -112 -114 -116 -117 -119 -119 -120 -120 -120 -119 -119 -117 -116 -114 -112 -110 -107 -104 -101 -97 -93 -89 -85 -80 -75 -70 -65 -60 -54 -49 -43 -37 -31 -25 -18 -12 -6 0 6 12 18 25 31 37 43 49 54 60 65 70 75 80 85 89 93 97 101 104 107 110 112 114 116 117 119 119 120)
COSTABLEI=(-120 -120 -119 -119 -117 -116 -114 -112 -110 -107 -104 -101 -97 -93 -89 -85 -80 -75 -70 -65 -60 -54 -49 -43 -37 -31 -25 -18 -12 -6 0 6 12 18 25 31 37 43 49 54 60 65 70 75 80 85 89 93 97 101 104 107 110 112 114 116 117 119 119 120 120 120 119 119 117 116 114 112 110 107 104 101 97 93 89 85 80 75 70 65 60 54 49 43 37 31 25 18 12 6 0 -6 -12 -18 -25 -31 -37 -43 -49 -54 -60 -65 -70 -75 -80 -85 -89 -93 -97 -101 -104 -107 -110 -112 -114 -116 -117 -119 -119 -120)

function range { eval echo {$1..$2}; }
function prerange { eval echo $1{$2..$3}; }


##
## Time stuff
##
## Consider time as normalized values:  hours [0..240] minuts & seconds [0..120].
## I do this because the above trig function domains are [0..120].
##
hour=0
min=0
sec=0
function timeProbe {
  local h m s
  if [ $# == 1 ]; then
    read h m s <<< $(date -r $1 +'%H %M %S')
  else
    read h m s  <<< $(date +'%H %M %S')
  fi
  hour=$((10#$h * 10)) #10# forces base 10 values otherwise octal 09 can't be parsed.
  min=$((10#$m * 2))
  sec=$((10#$s * 2))
}
timeProbe $(date +'%H %M %S')



##
## Terminal stuff
##
TWIDTH=80
TWIDTH2=40
THEIGHT=25
THEIGHT2=13
function hex { printf "%02x" $1; }
# UTF-8 critter glyphs
function acritter { printf "\xf0\x9f\x90\x${1:-$(hex $((128+RANDOM%64)))}"; }
function resetCritters {
  animal1=$(acritter)
  animal2=$(acritter)
  animal3=$(acritter)
}
resetCritters

function terminalProbe {
  read THEIGHT TWIDTH <<<$(stty size)
  THEIGHT2=$((THEIGHT/2))
  TWIDTH2=$((TWIDTH/2))
}

function terminalIsInScreen { # ARGS: x y
  local x=$(($1+TWIDTH2))
  local y=$(($2+THEIGHT2))
  if [ $x -lt 0 ] || [ $y -lt 0 ] || [ $TWIDTH -le $x ] || [ $THEIGHT -le $y ]; then
    return 1
  fi
  return 0
}

function G2 { printf "\e[$(($1+THEIGHT2));$(($2+TWIDTH2))H$3"; }

function terminalDrawLine {
  local x y m n d dx dy w ws nx ny yyxx e i
  local z=$5
  local kl=$6
  local ch=$7
  # Make sure line is drawn from left -x to right +x in the temrinal.
  if [ $2 -le $4 ]; then
    x=$2; y=$1; m=$4; n=$3
  else
    x=$4; y=$3; m=$2; n=$1
  fi
  # (x,y) to (m,n) will always go left to right
  dx=$((m-x))
  if [ $1 -lt $3 ]; then dy=$(($3-$1)); else dy=$(($1-$3)); fi

  # Always walk or walk-step

  if [ $dy -lt $dx ]; then # Small slope so walk left and step up or down
    w=''; xwi=1;  ywi=0
    if [ $y -lt $n ]; then # walk right and down
       ws=$'\v'; xwsi=1; ywsi=1
    else                   # walk right and up
       ws=$'\eM'; xwsi=1; ywsi=-1
    fi
    nx=$dx
    ny=$dy
  else # Large slope, so walk up or down and step right
    if [ $y -lt $n ]; then # walk down and right
       w=$'\b\v'; xwi=0; ywi=1
       ws=$'\v'; xwsi=1; ywsi=1
    else                   # walk up and right
       w=$'\b\eM'; xwi=0; ywi=-1
       ws=$'\eM'; xwsi=1; ywsi=-1
    fi
    nx=$dy
    ny=$dx
  fi

  # Valid state when drawing lines on the terminal
  #  0 = out
  #  1 = in
  local state=0

  yy=$((ny + ny))
  yyxx=$((yy - nx - nx))
  e=$((yy - nx))
  i=$nx

  while [ 0 -lt $i ]; do
    if [ 0 -le $e ]; then # above mid-point
      if [ $state == 1 ]; then
        if terminalIsInScreen $x $y; then # done if out of screen
          echo $((x+TWIDTH2)) $((y+THEIGHT2)) $z $kl $ch
        else
           return 0
        fi
      else # state == 0
        if terminalIsInScreen $x $y; then
          state=1
          echo $((x+TWIDTH2)) $((y+THEIGHT2)) $z $kl $ch
        fi
      fi
      x=$((x+xwsi)); y=$((y+ywsi))
      e=$((e + yyxx))
    else # below mid-point
      if [ $state == 1 ]; then
        if terminalIsInScreen $x $y; then  # done if out of screen
          echo $((x+TWIDTH2)) $((y+THEIGHT2)) $z $kl $ch
        else
          return 0
        fi
      else # state == 0
        if terminalIsInScreen $x $y; then
          state=1
          echo $((x+TWIDTH2)) $((y+THEIGHT2)) $z $kl $ch
        fi
      fi
      x=$((x+xwi)); y=$((y+ywi))
      e=$((e + yy))
    fi
    i=$((i-1))
  done
}


function terminalDrawLineDirect {
  local x y m n d dx dy w ws nx ny yyxx e i
  # Make sure line is drawn from left -x to right +x in the temrinal.
  if [ $2 -le $4 ]; then
    x=$2; y=$1; m=$4; n=$3
  else
    x=$4; y=$3; m=$2; n=$1
  fi
  # (x,y) to (m,n) will always go left to right
  dx=$((m-x))
  if [ $1 -lt $3 ]; then dy=$(($3-$1)); else dy=$(($1-$3)); fi

  # Always walk or walk-step

  if [ $dy -lt $dx ]; then # Small slope so walk left and step up or down
    w=''; xwi=1;  ywi=0
    if [ $y -lt $n ]; then # walk right and down
       ws=$'\v'; xwsi=1; ywsi=1
    else                   # walk right and up
       ws=$'\eM'; xwsi=1; ywsi=-1
    fi
    nx=$dx
    ny=$dy
  else # Large slope, so walk up or down and step right
    if [ $y -lt $n ]; then # walk down and right
       w=$'\b\v'; xwi=0; ywi=1
       ws=$'\v'; xwsi=1; ywsi=1
    else                   # walk up and right
       w=$'\b\eM'; xwi=0; ywi=-1
       ws=$'\eM'; xwsi=1; ywsi=-1
    fi
    nx=$dy
    ny=$dx
  fi

  # Valid state when drawing lines on the terminal
  #  0 = out
  #  1 = in
  local state=0

  yy=$((ny + ny))
  yyxx=$((yy - nx - nx))
  e=$((yy - nx))
  i=$nx

  while [ 0 -lt $i ]; do
    if [ 0 -le $e ]; then
      if [ $state == 1 ]; then
        if ! terminalIsInScreen $x $y; then # done if out of screen
           return 0
        fi
        printf "$ws$5"
      else # state == 0
        if terminalIsInScreen $x $y; then
          G2 $y $x $5
          state=1
        fi
      fi
      x=$((x+xwsi)); y=$((y+ywsi))
      e=$((e + yyxx))
    else
      if [ $state == 1 ]; then
        if !terminalIsInScreen $x $y; then # done if out of screen
          return 0
        fi
        printf $w$5
      else # state == 0
        if terminalIsInScreen $x $y
          then G2 $y $x $5
          state=1
        fi
      fi
      x=$((x+xwi)); y=$((y+ywi))
      e=$((e + yy))
    fi
    i=$((i-1))
  done
}



##
## Debugging
##
dv   (){ while [ 0 -lt $# ]; do printf '[%3d %3d %3d %3d ]\n' $1 $2 $3 $4; shift 4; done; }
dvgl (){ while [ 0 -lt $# ]; do printf "($2 $3 $4 $5 $6)\n"; shift 6; done; }
dvn  (){ while [ 0 -lt $# ]; do printf '[%6d %6d %6d %6d | %6d]\n' $(($1/$4)) $(($2/$4)) $(($3/$4)) $(($4/$4)) $4; shift 4; done; }
dm4  (){ printf '[%9d %9d %9d %9d]\n' $1 $2 $3 $4 $5 $6 $7 $8 $9 ${10} ${11} ${12} ${13} ${14} ${15} ${16}; }
COLORS=('0' '0;31' '0;32' '0;33' '0;34' '0;35' '0;36' '0;37' '1;30' '1;31' '1;32' '1;33' '1;34' '1;35' '1;36' '1;37')
function PC { local c=$1; shift; printf "\e[${COLORS[c]}m$*"; }



##
## Vectors:  array of concatenated homogeneous 4d vectors.  (size count length)
##
vectors=()
function vectorsLength { echo $((${#vectors[*]}/4)); }
#function vectorsSetXYZN  {
#  local i=$1
#  x=${vectors[$i*4]}
#  y=${vectors[$i*4+1]}
#  z=${vectors[$i*4+2]}
#  n=${vectors[$i*4+3]}
#}
function vectorsAppend { # Args:  x y z n ...
  local len=${#vectors[*]}
  ret=$((len/4)) # keep track of the starting vector index
  while [ 0 -lt $# ]; do
    vectors[len+0]=$1
    vectors[len+1]=$2
    vectors[len+2]=$3
    vectors[len+3]=$4
    shift 4
    len=$((len+4))
  done
}

function vectorsDump {
  local i=0
  echo "-- $(vectorsLength) vectors ----"
  dv ${vectors[*]} | while read x; do echo $i $x; i=$((i+1)); done
}



#### _Planes_
##
## Array of indices into the vectors array pointing at groups of 3 vertices.
##
planes=()    # Array of vector indices that reference three points defining a plane
facing=(1 0) # Result of normal calc for each plane (group of 3 normalized vertices) with two defaults (false true)
function planesLength { echo $((${#planes[*]})); }
function planesAppend { # Args:  vectorsIdx... 
  local len=${#planes[*]}
  ret=$((len+2))
  while [ 0 -lt $# ]; do
    planes[len]=$1
    facing[len+2]=0
    shift
    len=$((len+1))
  done
}

function planesDump {
  local i=0 v
  echo "-- $(planesLength) planes ----"
  for v in ${planes[*]}; do
    echo $((v)) $(dv ${vectors[*]:v*4:12}) "${facing[i+2]}"
    i=$((i+1))
  done
}

assertEquals Planes \
"$(vectorsAppend 0 0 0 0  1 1 1 1  2 2 2 2
   vectorsAppend 8 0 0 0  8 1 1 1  8 2 2 2
   vectorsAppend 9 0 0 0  9 1 1 1  9 2 2 2
   planesAppend 0 3 6
   planesDump)" \
"$(echo '-- 3 planes ----'
   echo '0 [ 0 0 0 0 ] [ 1 1 1 1 ] [ 2 2 2 2 ] 0'
   echo '3 [ 8 0 0 0 ] [ 8 1 1 1 ] [ 8 2 2 2 ] 0'
   echo '6 [ 9 0 0 0 ] [ 9 1 1 1 ] [ 9 2 2 2 ] 0')"
##
#### _Planes_


##
## Objects: Array of objects representing points, lines, and closed polygon
##
objects=() #( label type color char idxCount idx... ...)

function objectsLength { : || complicated;  }

function objectsAdd { # Args: label type color char planesIdx count vectorsIdx...
  local len=${#objects[*]}
  objects[len+0]=$1 # label
  objects[len+1]=$2 # type
  objects[len+2]=$3 # color
  objects[len+3]=$4 # char
  objects[len+4]=$5 # planesIdx
  shift 5
  objects[len+5]=$(($#)) # vector count
  len=$((len+6))
  while [ 0 -lt $# ]; do
    objects[len]=$1
    shift
    len=$((len+1))
  done
}

function objectsDump {
  echo "-- objects ----"
  local oi=0 max=${#objects[*]} count p
  while [ $oi -lt $max ]; do
    printf "%8s %s [%d%s]" "\"${objects[oi+0]}\"" ${objects[oi+1]} ${objects[oi+2]} ${objects[oi+3]}
    p=${objects[oi+4]}
    case $p in
      (0) printf "{F}" ;;
      (1) printf "{T}" ;;
      (*) printf "{%d}" $((p-2)) ;;
    esac
    count=${objects[oi+5]}
    printf " $count:"
    oi=$((oi+6))
    case ${objects[oi-5]} in
      (*) printf " %s" ${objects[*]:oi:count} ;;      # Dump indices representing each point
      (l) printf " %2d-%-2d" ${objects[*]:oi:count} ;; # Dump index pairs representing a line
    esac
    echo "."
    oi=$((oi + count))
  done
}



##
## Matrix
##

identity="1 0 0 0  0 1 0 0   0 0 1 0  0 0 0 1"
function matRotz () { echo ${COSTABLE[(120+$1)%120]} ${SINTABLEI[(120+$1)%120]} 0 0 ${SINTABLE[(120+$1)%120]} ${COSTABLE[(120+$1)%120]} 0 0 0 0 120 0 0 0 0 120; }
function matRoty () { echo ${COSTABLE[(120+$1)%120]} 0 ${SINTABLEI[(120+$1)%120]} 0 0 120 0 0 ${SINTABLE[(120+$1)%120]} 0 ${COSTABLE[(120+$1)%120]} 0 0 0 0 120; }
function matRotx () { echo 120 0 0 0 0 ${COSTABLE[(120+$1)%120]} ${SINTABLE[(120+$1)%120]} 0 0   ${SINTABLEI[(120+$1)%120]} ${COSTABLE[(120+$1)%120]} 0 0 0 0 120; }
function matScale () { echo $1 0 0 0  0 $2 0 0  0 0 $3 0  0 0 0 1; }
function matTrans () { echo 1 0 0 $1  0 1 0 $2  0 0 1 $3  0 0 0 1; }
function matPerspective () { echo 1000 0 0 0  0 1000 0 0  0 0 1000 0  0 0 $((1000/$1)) 1000; }

#
# Multiply 4x4 row vector arg1 with 4xN column vector (remaining args).
#  Arg1 = 'a b c d  e f g h  i j k l  m n o p'
#  Arg* = x0 y0 z0 1  x1 y1 z1 1  ...
#
function matMult () {
  local a=$1 b=$2 c=$3 d=$4 e=$5 f=$6 g=$7 h=$8 i=$9 j=${10} k=${11} l=${12} m=${13} n=${14} o=${15} p=${16}
  shift 12
  while [ 8 -le $# ] && shift 4; do
    echo $((a*$1+b*$2+c*$3+d*$4)) $((e*$1+f*$2+g*$3+h*$4)) $((i*$1+j*$2+k*$3+l*$4)) $((m*$1+n*$2+o*$3+p*$4))
  done
}


#
# Multiply N 4x4 row vectors passed as non-grouped expanded args
#  Args: a b c d  e f g h  i j k l  m n o p ...
#
function matMultXform () {
 local aa bb cc dd ee ff gg hh ii jj kk ll mm nn oo pp
 local a=$1 b=$2 c=$3 d=$4 e=$5 f=$6 g=$7 h=$8 i=$9 j=${10} k=${11} l=${12} m=${13} n=${14} o=${15} p=${16}
 shift 16
 while :; do
   aa=$((a*$1 + b*$5 + c*$9    + d*${13}))
    bb=$((a*$2 + b*$6 + c*${10} + d*${14}))
     cc=$((a*$3 + b*$7 + c*${11} + d*${15}))
      dd=$((a*$4 + b*$8 + c*${12} + d*${16}))
   ee=$((e*$1 + f*$5 + g*$9    + h*${13}))
    ff=$((e*$2 + f*$6 + g*${10} + h*${14}))
     gg=$((e*$3 + f*$7 + g*${11} + h*${15}))
      hh=$((e*$4 + f*$8 + g*${12} + h*${16}))
   ii=$((i*$1 + j*$5 + k*$9    + l*${13}))
    jj=$((i*$2 + j*$6 + k*${10} + l*${14}))
     kk=$((i*$3 + j*$7 + k*${11} + l*${15}))
      ll=$((i*$4 + j*$8 + k*${12} + l*${16}))
   mm=$((m*$1 + n*$5 + o*$9    + p*${13}))
    nn=$((m*$2 + n*$6 + o*${10} + p*${14}))
     oo=$((m*$3 + n*$7 + o*${11} + p*${15}))
      pp=$((m*$4 + n*$8 + o*${12} + p*${16}))
   if [ 16 -eq $# ]; then echo $aa $bb $cc $dd $ee $ff $gg $hh $ii $jj $kk $ll $mm $nn $oo $pp; return; fi
   shift 16
   a=$((aa*$1 + bb*$5 + cc*$9    + dd*${13}))
    b=$((aa*$2 + bb*$6 + cc*${10} + dd*${14}))
     c=$((aa*$3 + bb*$7 + cc*${11} + dd*${15}))
      d=$((aa*$4 + bb*$8 + cc*${12} + dd*${16}))
   e=$((ee*$1 + ff*$5 + gg*$9    + hh*${13}))
    f=$((ee*$2 + ff*$6 + gg*${10} + hh*${14}))
     g=$((ee*$3 + ff*$7 + gg*${11} + hh*${15}))
      h=$((ee*$4 + ff*$8 + gg*${12} + hh*${16}))
   i=$((ii*$1 + jj*$5 + kk*$9    + ll*${13}))
    j=$((ii*$2 + jj*$6 + kk*${10} + ll*${14}))
     k=$((ii*$3 + jj*$7 + kk*${11} + ll*${15}))
      l=$((ii*$4 + jj*$8 + kk*${12} + ll*${16}))
   m=$((mm*$1 + nn*$5 + oo*$9    + pp*${13}))
    n=$((mm*$2 + nn*$6 + oo*${10} + pp*${14}))
     o=$((mm*$3 + nn*$7 + oo*${11} + pp*${15}))
      p=$((mm*$4 + nn*$8 + oo*${12} + pp*${16}))
   if [ 16 -eq $# ]; then echo $a $b $c $d $e $f $g $h $i $j $k $l $m $n $o $p; return; fi
   shift 16
 done
}

# This isn't any faster.  Expects &mat and N matrices passed symbolically expanded.
function matMultXformLocal () {
 local a b c d
 while :; do
   a=${mat[0]}
   b=${mat[1]}
   c=${mat[2]}
   d=${mat[3]}
   mat[0]=$((a*$1 + b*$5 + c*$9    + d*${13}))
    mat[1]=$((a*$2 + b*$6 + c*${10} + d*${14}))
     mat[2]=$((a*$3 + b*$7 + c*${11} + d*${15}))
      mat[3]=$((a*$4 + b*$8 + c*${12} + d*${16}))
   a=${mat[4]}
   b=${mat[5]}
   c=${mat[6]}
   d=${mat[7]}
   mat[4]=$((a*$1 + b*$5 + c*$9    + d*${13}))
    mat[5]=$((a*$2 + b*$6 + c*${10} + d*${14}))
     mat[6]=$((a*$3 + b*$7 + c*${11} + d*${15}))
      mat[7]=$((a*$4 + b*$8 + c*${12} + d*${16}))
   a=${mat[8]}
   b=${mat[9]}
   c=${mat[10]}
   d=${mat[11]}
   mat[8]=$((a*$1 + b*$5 + c*$9    + d*${13}))
    mat[9]=$((a*$2 + b*$6 + c*${10} + d*${14}))
     mat[10]=$((a*$3 + b*$7 + c*${11} + d*${15}))
      mat[11]=$((a*$4 + b*$8 + c*${12} + d*${16}))
   a=${mat[12]}
   b=${mat[13]}
   c=${mat[14]}
   d=${mat[15]}
   mat[12]=$((a*$1 + b*$5 + c*$9    + d*${13}))
    mat[13]=$((a*$2 + b*$6 + c*${10} + d*${14}))
     mat[14]=$((a*$3 + b*$7 + c*${11} + d*${15}))
      mat[15]=$((a*$4 + b*$8 + c*${12} + d*${16}))
   [ 32 -le $# ] || break
   shift 16
 done
}


function matMultLocal { # &mat &vx &vy &vz &vn => &x &y &z &n
  x=$((mat[0]*vx+mat[1]*vy+mat[2]*vz+mat[3]*vn))
  y=$((mat[4]*vx+mat[5]*vy+mat[6]*vz+mat[7]*vn))
  z=$((mat[8]*vx+mat[9]*vy+mat[10]*vz+mat[11]*vn))
  n=$((mat[12]*vx+mat[13]*vy+mat[14]*vz+mat[15]*vn))
}


# Given index into vectors array (... x y z n   x' y' z' n'   x" y" z" n" ...)
# Which define two vectors starting at x y z,
# Return true if the normal is facing viewer
# Completely inlined matrix multiply and normal calculation
function isObjectFacing { # &planeIndex &mat
  local vi=$((planeIndex*4)) vi vx vy vz vn x y n nx0 ny0 nn0 nx1 ny1 nn1 xy zy

  vx=${vectors[vi]}
  vy=${vectors[vi+1]}
  vz=${vectors[vi+2]}
  vn=${vectors[vi+3]}
  nx0=$((mat[0]*vx+mat[1]*vy+mat[2]*vz+mat[3]*vn))
  ny0=$((mat[4]*vx+mat[5]*vy+mat[6]*vz+mat[7]*vn))
  nn0=$((mat[12]*vx+mat[13]*vy+mat[14]*vz+mat[15]*vn))

  vx=${vectors[vi+4]}
  vy=${vectors[vi+5]}
  vz=${vectors[vi+6]}
  vn=${vectors[vi+7]}
  nx1=$((mat[0]*vx+mat[1]*vy+mat[2]*vz+mat[3]*vn))
  ny1=$((mat[4]*vx+mat[5]*vy+mat[6]*vz+mat[7]*vn))
  nn1=$((mat[12]*vx+mat[13]*vy+mat[14]*vz+mat[15]*vn))

  vx=${vectors[vi+8]}
  vy=${vectors[vi+9]}
  vz=${vectors[vi+10]}
  vn=${vectors[vi+11]}
  x=$((mat[0]*vx+mat[1]*vy+mat[2]*vz+mat[3]*vn))
  y=$((mat[4]*vx+mat[5]*vy+mat[6]*vz+mat[7]*vn))
  n=$((mat[12]*vx+mat[13]*vy+mat[14]*vz+mat[15]*vn))

  zx=$((4*nx0/nn0))
  zy=$((4*ny0/nn0))
  [ $(((4*nx1/nn1-zx)*(4*y/n-zy) - (4*ny1/nn1-zy)*(4*x/n-zx))) -lt 0 ]
}

function plotLines () { # &oi &cl &ch &last &mat
  local idx vi vx vy vz vn a b c x y z n
  idx=$oi
  while [ $idx -lt $last ]; do # over every vector index in object
    vi=${objects[idx]}
    vx=${vectors[$vi*4]}
    vy=${vectors[$vi*4+1]}
    vz=${vectors[$vi*4+2]}
    vn=${vectors[$vi*4+3]}
    matMultLocal # Uses: mat vx vy vz vn
    a=$((x/n))
    b=$((y/n))
    c=$((z/n))
    vi=${objects[idx+1]}
    vx=${vectors[$vi*4]}
    vy=${vectors[$vi*4+1]}
    vz=${vectors[$vi*4+2]}
    vn=${vectors[$vi*4+3]}
    matMultLocal # Uses: mat vx vy vz vn
    x=$((x/n))
    y=$((y/n))
    terminalDrawLine  $b $a $y $x $c $cl $ch
    idx=$((idx+2))
  done
}

function plotPoly () { # &cl &ch &oi &last
  local idx vi vi vx vy vz vn ox oy oz on lx ly lz x y z
  idx=$oi
  # Keep track of first point
  vi=${objects[idx]}
  vx=${vectors[$vi*4]}
  vy=${vectors[$vi*4+1]}
  vz=${vectors[$vi*4+2]}
  vn=${vectors[$vi*4+3]}
  matMultLocal # Uses: mat vx vy vz vn  Sets x y z n
  ox=$((x/n))
  oy=$((y/n))
  oz=$((z/n))
  lx=$ox
  ly=$oy
  lz=$oz
  idx=$((idx+1))
  while [ $idx -lt $last ]; do # over every vector index in object
    vi=${objects[idx]}
    vx=${vectors[$vi*4]}
    vy=${vectors[$vi*4+1]}
    vz=${vectors[$vi*4+2]}
    vn=${vectors[$vi*4+3]}
    matMultLocal # Uses: mat vx vy vz vn
    x=$((x/n))
    y=$((y/n))
    z=$((z/n))
    terminalDrawLine  $ly $lx $y $x $lz $cl $ch
    lx=$x
    ly=$y
    lz=$z
    idx=$((idx+1))
  done
  terminalDrawLine  $y $x $oy $ox $z $cl $ch
}

function plotPoints () { # &oi &cl &ch &last
  local idx=$oi vi vx vy vz vn x y z n
  idx=$oi
  while [ $idx -lt $last ]; do # over every vector index in object
    vi=${objects[idx]} # Vector index in vectors array
    vx=${vectors[$vi*4]}
    vy=${vectors[$vi*4+1]}
    vz=${vectors[$vi*4+2]}
    vn=${vectors[$vi*4+3]}
    matMultLocal # Uses: mat vx vy vz vn
    x=$((x/n)) # normalize each component
    y=$((y/n))
    z=$((z/n))
    terminalIsInScreen $x $y && echo $((x+TWIDTH2)) $((y+THEIGHT2)) $z $cl $ch
    idx=$((idx+1))
  done
}



##
## Globals
##
powerButton=true
jiffy=$SECONDS 
frame=0
framestop=60
sigwinch=false
matrixPerspective=$(matMultXform $(matPerspective 60) $(matTrans 0 0 100) $(matScale 4 2 2))
#matrixPerspective="$identity"



##
## Rendering and Scheduling
##
screenBufferEmpty=""
depthBufferEmpty=""

function resetEmptyBuffers {
  screenBufferEmpty="$(printf "%.s' ' "  $(range 1 $((TWIDTH*THEIGHT))))"
  depthBufferEmpty="$(printf "%.s9999 " $(range 1 $((TWIDTH*THEIGHT))))"
}

function renderObjectSet { # &oil &frame &thread
 trap : SIGINT
 trap : SIGQUIT
 trap : SIGWINCH
 local oi type cl ch count last
 for oi in ${oil[*]}; do
    type=${objects[oi+1]}
    cl=${objects[oi+2]}
    ch=${objects[oi+3]}
    count=${objects[oi+5]}
    oi=$((oi+6))
    last=$((count + oi)) # compute index of last element in this object
      case $type in # &cl &ch &oi &last
       (p) plotPoints ;;
       (l) plotLines ;;
       (y) plotPoly ;;
      esac
 done
 echo "q"
}

function scheduleObjectRenderers { # &frame &thread
  # over all objects
  while [ $oi -lt $max ]; do
    #symbol=${objects[oi+0]}
    type=${objects[oi+1]}
    cl=${objects[oi+2]}
    ch=${objects[oi+3]}
    plane=${objects[oi+4]}
    count=${objects[oi+5]}
    oi=$((oi+6))
    last=$((count + oi)) # compute index of last element in this object
    if [ ${facing[plane]} -eq 0 ]; then
      oil[oilc]=$((oi-6))
      oilc=$((oilc+1))
      if [ 10 -lt $oilc ]; then # more things happen per thread the higher this number is
        thread=$((thread+1))
        renderObjectSet > "${frame}_$thread" &
        oil=()
        oilc=0
      fi fi
    oi=$last # Skip object index to next object in array
  done

  if [ 0 -lt $oilc ]; then # Run any threads in the partially full list
    thread=$((thread+1))
    renderObjectSet > "${frame}_$thread" &
  fi
}


function doNormals { # &mat
  local planeIndex i=2 # skip the first two fixed normal bools
  for planeIndex in ${planes[*]}; do
    isObjectFacing # &planeIndex &mat
    facing[i]=$?
    #[ ${facing[i]} -eq 0 ] && facingCount=$((facingCount+1))
    i=$((i+1))
  done
}

function fillDepthBuffer { # &frame &thread &screenBuffer &depthBuffer
  # clear the screen buffer
  local idx x y z k c i=0
  for filename in $(prerange ${frame}_ 1 $thread); do
    while [ ! -e $filename ]; do
      echo $filename no exist
      sleep 1
    done # spin until the file is created
    while :; do
      read x y z k c
      if [ -z "$x" ]; then
        echo "'[$x,$y,$z,$k,$c]' continue..."
        sleep 1
        continue
      fi
      [ "$x" == q ] && break
        idx=$((x+y*TWIDTH))
        if [ $z -lt ${depthBuffer[idx]} ]; then
          screenBuffer[idx]="[${COLORS[k]}m$c"
          depthBuffer[idx]=$z
        fi
    done <"$filename"
    rm $filename # Remove the files the rendering processes created
    i=$((i+1))
  done
}

function dumpStats {
  # parent: facing thread
  if [ $SECONDS -ne 0 ]; then
    frameRate=$((100*frame/(SECONDS)))
    PC 8 "\e[$((THEIGHT-3))Hframe:$frame\nfps:$((frameRate/100)).$((frameRate%100))\nthreads:$thread" # facing:$facingCount
  fi
}

function renderObjects {
  [ $sec == 0 ] || [ "$1" == -resetCritters ] && resetCritters # Animal glyphs reset every minute or screen resize.
  local facingCount=0 thread=0 screenBuffer depthBuffer max=${#objects[*]} oi=0 label type cl ch plane count x y z n last oil=() oilc=0
  #local mat=($(matMultXform $matrixPerspective $(matRotz $((frame))) $(matRotx $((frame))) $(matRoty $((frame))) $(matTrans 0 0 0) ))
  local mat=($(matMultXform $matrixPerspective $(matRoty $((frame/1))) ))

  doNormals
  scheduleObjectRenderers # &frame &thread -- Creates files with "x y z k c" per line
  if [ $thread != 0 ]; then
    eval screenBuffer=($screenBufferEmpty)
    depthBuffer=($depthBufferEmpty)
    if :; then
      trap : SIGINT
      trap : SIGQUIT
      trap : SIGWINCH
      fillDepthBuffer # &frame &thread &screenBuffer &depthBuffer
      IFS=''
      printf "\e[H${screenBuffer[*]}$(dumpStats)" # &facingCount &thread
      unset IFS
    fi &
  fi
  frame=$((frame+1))
}


##
## Build Models
##
clockIdx=0
clockRadius=10
function buildClock {
  local r=$1 s=$((- $1)) face=$2 tr idx nidx ret
  local b=$((r+0))
  shift 2
  clockRadius=$r
  case $face in
   (0) tr=$(matMultXform $(matRoty  0) $(matTrans 0 0 -$b)) ;;
   (1) tr=$(matMultXform $(matRoty 30) $(matTrans 0 0 -$b)) ;;
   (2) tr=$(matMultXform $(matRoty 60) $(matTrans 0 0 -$b)) ;;
   (3) tr=$(matMultXform $(matRoty 90) $(matTrans 0 0 -$b)) ;;
   (4) tr=$(matMultXform $(matRotx 30) $(matTrans 0 0 -$b)) ;;
   (5) tr=$(matMultXform $(matRotx 90) $(matTrans 0 0 -$b)) ;;
  esac

  # plane vectors for normal calculatoin.
  # The first three vectors will be used to calculate the culling normal for the entire clock.
  vectorsAppend  $(matMult $tr  0 0 0 1   $r 0 0 1   0 $s 0 1)
  idx=$ret # The index to these vectors is used a bunch of times
  planesAppend $idx # Register the vectors index of these three points
  pidx=$ret # Keep track of this plane's index as it's used by all the objects on this plane

  vectorsAppend  $(matMult $tr  0 $s 0 1   $r 0 0 1   $r $r 0 1)
  objectsAdd HOUR l 6 _  $pidx $idx $((ret))
  objectsAdd MIN  l 2 _  $pidx $idx $((ret+1))
  objectsAdd SEC  l 5 _  $pidx $idx $((ret+2))

  vectorsAppend  $(matMult $tr  $s $s 0 1  $r $s 0 1   $r $r 0 1  $s $r 0 1 )
  objectsAdd BOX  y $((face+1)) . $pidx $((ret)) $((ret+1)) $((ret+2)) $((ret+3))

  for s in 10 20 30 40 50 60 70 80 90 100 110; do
    vectorsAppend $(matMult $(matMultXform $tr $(matRotz $s))  0 $((r/2)) 0 1   0 $r 0 1)
    objectsAdd TICK l 8 . $pidx $ret $((ret + 1))
  done
}

function updateClock {
  timeProbe # $((frame*483))
  vectors[(clockIdx+3)*4+0]=$((COSTABLE[(hour+90)%120]*clockRadius/240))
  vectors[(clockIdx+3)*4+1]=$((SINTABLE[(hour+90)%120]*clockRadius/240))
  vectors[(clockIdx+4)*4+0]=$((COSTABLE[(min+90)%120]*clockRadius/120))
  vectors[(clockIdx+4)*4+1]=$((SINTABLE[(min+90)%120]*clockRadius/120))
  vectors[(clockIdx+5)*4+0]=$((COSTABLE[(sec+90)%120]*clockRadius/120))
  vectors[(clockIdx+5)*4+1]=$((SINTABLE[(sec+90)%120]*clockRadius/120))
}




function buildTexturedCubes {
  local r=$1 # radius of the cubes
  local s=$2 # distance between cubes
  local d=$3 # density of the cubes
  function buildTexturedFace {
    local  x  y=$((-r/d-0))
    echo $y $y 0 1   $y $((r/d-1)) 0 1   $((r/d-1)) $y 0 1
    while [ $y -le $((r/d)) ]; do
      x=$((-r/d-0))
      while [ $x -le $((r/d)) ]; do
        echo -n "$((d*x)) $((d*y)) 0 1 "
        x=$((x+1))
      done
      y=$((y+1))
    done
  }
  function buildFaceRotation {
    case $1 in
      (0) matMultXform $(matTrans $2 $3 $4) $(matRoty  0) $(matTrans 0 0 -$r) ;;
      (1) matMultXform $(matTrans $2 $3 $4) $(matRoty 30) $(matTrans 0 0 -$r) ;;
      (2) matMultXform $(matTrans $2 $3 $4) $(matRoty 60) $(matTrans 0 0 -$r) ;;
      (3) matMultXform $(matTrans $2 $3 $4) $(matRoty 90) $(matTrans 0 0 -$r) ;;
      (4) matMultXform $(matTrans $2 $3 $4) $(matRotx 30) $(matTrans 0 0 -$r) ;;
      (5) matMultXform $(matTrans $2 $3 $4) $(matRotx 90) $(matTrans 0 0 -$r) ;;
      (*) exit -1
    esac
  }
  function buildTexturedCube {
    local ret idx pidx

    vectorsAppend $(matMult $(buildFaceRotation 0 $1 $2 $3) $(buildTexturedFace)); idx=$ret
    planesAppend $idx; pidx=$ret
    objectsAdd CUBE p 1 @  $pidx $(range $((idx+3)) $((idx+3+$(( $(vectorsLength) - idx - 4 ))))) # color char idx...

    vectorsAppend $(matMult $(buildFaceRotation 1 $1 $2 $3) $(buildTexturedFace)); idx=$ret
    planesAppend $idx; pidx=$ret
    objectsAdd CUBE p 2 @  $pidx $(range $((idx+3)) $((idx+3+$(( $(vectorsLength) - idx - 4 ))))) # color char idx...

    vectorsAppend $(matMult $(buildFaceRotation 2 $1 $2 $3) $(buildTexturedFace)); idx=$ret
    planesAppend $idx; pidx=$ret
    objectsAdd CUBE p 3 @  $pidx $(range $((idx+3)) $((idx+3+$(( $(vectorsLength) - idx - 4 ))))) # color char idx...

    vectorsAppend $(matMult $(buildFaceRotation 3 $1 $2 $3) $(buildTexturedFace)); idx=$ret
    planesAppend $idx; pidx=$ret
    objectsAdd CUBE p 4 @  $pidx $(range $((idx+3)) $((idx+3+$(( $(vectorsLength) - idx - 4 ))))) # color char idx...

    vectorsAppend $(matMult $(buildFaceRotation 4 $1 $2 $3) $(buildTexturedFace)); idx=$ret
    planesAppend $idx; pidx=$ret
    objectsAdd CUBE p 5 @  $pidx $(range $((idx+3)) $((idx+3+$(( $(vectorsLength) - idx - 4 ))))) # color char idx...

    vectorsAppend $(matMult $(buildFaceRotation 5 $1 $2 $3) $(buildTexturedFace)); idx=$ret
    planesAppend $idx; pidx=$ret
    objectsAdd CUBE p 6 @  $pidx $(range $((idx+3)) $((idx+3+$(( $(vectorsLength) - idx - 4 ))))) # color char idx...
  }
  buildTexturedCube  $s   10   0
  buildTexturedCube -$s   10   0
  buildTexturedCube   0   10  $s
  buildTexturedCube   0   10 -$s
} # buildTexturedCubes


function buildFloor {
  local ret
  local r=$1 # radius of the cubes
  local s=$2 # floor height
  local d=$3 # density of the cubes

  function buildTexturedFace {
    local  x  z=$((-r/d))
    #echo 0 0 0 1  0 0 0 1  0 0 0 1
    while [ $z -le $((r/d)) ]; do
      x=$((-r/d))
      while [ $x -le $((r/d)) ]; do
        echo -n "$((d*x)) 0 $((d*z)) 1 "
        x=$((x+1))
      done
      z=$((z+1))
    done
  }
  vectorsAppend $(matMult $(matTrans 0 $s 0) $(buildTexturedFace))
  objectsAdd FLOOR p 8 .  1 $(range $((ret+3)) $((ret+$(( $(vectorsLength) - ret - 1)))))
}



#bb=0
#function updateBoxes {
#  vectors[(bb+0)*4+1]=$((SINTABLE[(1*frame+10)%120]/8))
#  vectors[(bb+1)*4+1]=$((SINTABLE[(1*frame+21)%120]/8))
#  vectors[(bb+2)*4+1]=$((SINTABLE[(1*frame+32)%120]/8))
#  vectors[(bb+3)*4+1]=$((SINTABLE[(1*frame+43)%120]/8))
#  vectors[(bb+4)*4+1]=$((SINTABLE[(1*frame+61)%120]/8))
#  vectors[(bb+5)*4+1]=$((SINTABLE[(1*frame+72)%120]/8))
#  vectors[(bb+6)*4+1]=$((SINTABLE[(1*frame+83)%120]/8))
#  vectors[(bb+7)*4+1]=$((SINTABLE[(1*frame+94)%120]/8))
#}
function buildSimpleBox {
  # (1) Create the points
  local ret r=$1 idx
  vectorsAppend -$r $r $r 1  $r $r $r 1  $r -$r $r 1  -$r -$r $r 1   -$r $r -$r 1  $r $r -$r 1  $r -$r -$r 1  -$r -$r -$r 1
  #objectsAdd POINTS p 3 x 1  $(eval echo {$ret..$((ret+7))})
  objectsAdd BOX   y 6 + 1  $(range $ret $((ret+3)))  # back
  objectsAdd BOX   y 6 + 1  $(range $((ret+4)) $((ret+7)))  # front
  objectsAdd EDGES l 6 + 1  $((ret+1)) $((ret+5))  $((ret+2)) $((ret+6))  $((ret+3)) $((ret+7))  $((ret+4)) $ret
  r=$((r/2))
  vectorsAppend -$r $r $r 1  $r $r $r 1  $r -$r $r 1  -$r -$r $r 1   -$r $r -$r 1  $r $r -$r 1  $r -$r -$r 1  -$r -$r -$r 1
  #bb=$ret
  objectsAdd POINTS y 2 y 1  $(range $((ret+0)) $((ret+7)))
}

function buildUrchin {
  local origin ret c=$1 r=$2

  while [ 0 -lt $c ]; do
    vectorsAppend $(matMult $(matMultXform $(matTrans 40 -20 0) $(matRotx $((RANDOM%120))) $(matRoty $((RANDOM%120))) $(matRotz $((RANDOM%120))) ) $((r/2)) 0 0 1 $r 0 0 1)
    objectsAdd LINE l $((RANDOM%15+1)) . 1 $origin $ret $((ret+1))
   c=$((c-1))
  done
}




##
## Exception handlers
##
function handler_sigint { powerButton=false; }
function handler_sigwinch { sigwinch=true; }


##
## USAGE:  basciiclock [a|b] {frame count}
##
function main {
  framestop=${1:--1}
  trap handler_sigint   SIGINT
  trap handler_sigint   SIGQUIT
  trap handler_sigwinch SIGWINCH
  printf "\e[?25l" # Disable cursor
  terminalProbe
  resetEmptyBuffers
  resetCritters

  buildUrchin 100 40
  #buildSimpleBox 30
  #buildTexturedCubes 7 35 3
  buildFloor 40 20 4
  if :; then
    buildClock 20 0
    buildClock 20 1
    buildClock 20 2
    buildClock 20 3
    buildClock 20 4
    buildClock 20 5
  fi
  #vectorsDump
  #objectsDump
  #planesDump
  #read -n 1 -p 'Abort, Retry, Fail?' k
  while [ ! -e stop ] && $powerButton && [ $frame -ne $framestop ] ; do
    if [ $jiffy != $SECONDS ]; then
      timeProbe # $((frame*483))
      jiffy=$SECONDS
    fi
    if $sigwinch; then
      echo handler
      wait
      terminalProbe
      resetEmptyBuffers
      sigwinch=false
    fi
    renderObjects
    #updateClock
    #updateBoxes
  done
  wait
  printf "\e[?25h\nDone.\n" # Enable cursor
}

#time main b 30 # Time run 60 frames
time main -10 # Run indefinitely or until ^C
